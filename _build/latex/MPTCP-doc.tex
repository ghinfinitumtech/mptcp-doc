%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}

\usepackage{sphinxcontribtikz}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


\usepackage{tikz}
\usepackage{xcolor}
\usepackage{bytefield}
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\usetikzlibrary{arrows,arrows.meta,positioning, matrix,backgrounds,shapes,shapes.symbols,shadows,calc,automata,math}


\title{Multipath TCP -- documentation}
\date{Nov 07, 2022}
\release{2022}
\author{Olivier Bonaventure}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Multipath TCP on recent Linux kernels}
\label{\detokenize{mptcp-linux:multipath-tcp-on-recent-linux-kernels}}\label{\detokenize{mptcp-linux::doc}}
\sphinxAtStartPar
Starting with version 5.6, the official Linux kernel includes support for Multipath TCP. The set of features supported by this implementation has increased over time as shown by its \sphinxhref{https://github.com/multipath-tcp/mptcp\_net-next/wiki}{ChangeLog}.

\sphinxAtStartPar
To avoid any interference with regular TCP, this implementation only creates a Multipath TCP connection if the application has created its \sphinxcode{\sphinxupquote{socket}} using the \sphinxcode{\sphinxupquote{IPPROTO\_MPTCP}} protocol. Applications will probably be modified in the coming months and years to add specific support for Multipath TCP, but in the mean time, the Multipath TCP developers have created a work around to force legacy applications to use Multipath TCP with the \sphinxcode{\sphinxupquote{mptcpize}} command which is bundled with the \sphinxhref{https://intel.github.io/mptcpd/}{mptcpd} daemon. We use this solution in this section.

\sphinxAtStartPar
To illustrate Multipath TCP, we use a very simple setup with a Linux client using Ubuntu 22 and a Linux server using Debian. The client uses Linux kernel version 5.15 while the server uses version 5.17. The server has a single network interface with an IPv4 and an IPv6 address. The client has both a Wi\sphinxhyphen{}Fi and an Ethernet interface. These two interfaces are connected to the same router that allocates IP addresses in the same subnet on both interfaces. The client has both an IPv4 and an IPv6 address.


\section{Enabling Multipath TCP}
\label{\detokenize{mptcp-linux:enabling-multipath-tcp}}
\sphinxAtStartPar
Multipath TCP is a feature that needs to be compiled inside the kernel. If you compile your own kernel, you can manually select Multipath TCP.

\sphinxAtStartPar
Most users prefer to rely on already compiled Linux kernels that are included in their distribution. The following distributions support Multipath TCP:
\begin{itemize}
\item {} 
\sphinxAtStartPar
CentOS starting with

\item {} 
\sphinxAtStartPar
Debian starting with

\item {} 
\sphinxAtStartPar
Ubuntu starting with 22.04

\end{itemize}

\sphinxAtStartPar
You need to to install a recent kernel to benefit from Multipath TCP. On some distributions, this installation will be part of the regular upgrade. On other distributions, you will need to add it manually.

\sphinxAtStartPar
Once the kernel has been installed and your computer has rebooted, you first need to verify that Multipath TCP is enabled.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo sysctl \PYGZhy{}a | grep mptcp.enabled}
\PYG{g+go}{net.mptcp.enabled = 1}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, the kernel supports Multipath TCP. If, for any reason, you want to disable Multipath TCP, you need to set this \sphinxcode{\sphinxupquote{sysctl}} variable to \sphinxcode{\sphinxupquote{0}}.

\sphinxAtStartPar
To illustrate the basic operation of \sphinxcode{\sphinxupquote{mptcpize}}, let us first use the netcat command over the loopback interface. This is obviously not the target use case for Multipath TCP, but a nice way to perform tests.

\sphinxAtStartPar
Netcat allows to easily launch clients and servers. We start the server using: \sphinxcode{\sphinxupquote{mptcpize run nc \sphinxhyphen{}l \sphinxhyphen{}p 12345}}. This is a TCP server that listens on port \sphinxcode{\sphinxupquote{12345}}. The client connects to this server using the \sphinxcode{\sphinxupquote{mptcpize run nc 127.0.0.1 12345}} command. The connection is established and all text lines sent by the client are printed by the server on standard output.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{} }mptcpize run nc \PYGZhy{}l \PYGZhy{}p \PYG{l+m}{12345}
\PYG{g+go}{Simple test}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are several ways to check that Multipath TCP is used for this connection. First, the \sphinxcode{\sphinxupquote{ss}} command provides information about the status of the different sockets.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ss \PYGZhy{}iaM}
\PYG{g+go}{State    Recv\PYGZhy{}Q    Send\PYGZhy{}Q       Local Address:Port        Peer Address:Port    Process}
\PYG{g+go}{ESTAB    0         0                127.0.0.1:12345          127.0.0.1:52854}
\PYG{g+go}{         subflows\PYGZus{}max:2 remote\PYGZus{}key token:5bba80d9 write\PYGZus{}seq:2266a099179e2476 snd\PYGZus{}una:2266a099179e2476 rcv\PYGZus{}nxt:de9999038d0a29a2}
\PYG{g+go}{ESTAB    0         0                127.0.0.1:52854          127.0.0.1:12345}
\PYG{g+go}{         subflows\PYGZus{}max:2 remote\PYGZus{}key token:c1f12b87 write\PYGZus{}seq:de9999038d0a29a2 snd\PYGZus{}una:de9999038d0a29a2 rcv\PYGZus{}nxt:2266a099179e2476}
\end{sphinxVerbatim}

\sphinxAtStartPar
ss provides several useful information to debug a Multipath TCP connection. The first column indicates that the connection is in the Established state, which means that it can currently transfer data. It also indicates the length of the Send and Receive queues at the TCP level and the four\sphinxhyphen{}tuple that identifies the connection. The next line provides Multipath TCP information with the maximum number of subflows which can be attached to the connection, the token assigned by the remote host and the write\_seq, snd\_una and rcv\_next parameters of the sate machine. The next two lines provide information about the other direction of the connection.

\sphinxAtStartPar
It is also possible to capture packets on the loopback interface to verify that Multipath TCP is used. The output below provides the first collected packets:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{tcpdump: verbose output suppressed, use \PYGZhy{}v[v]... for full protocol decode listening on lo, link\PYGZhy{}type EN10MB (Ethernet), snapshot length 262144 bytes}
\PYG{g+go}{18:43:42.676396 IP 127.0.0.1.52854 \PYGZgt{} 127.0.0.1.12345: Flags [S], seq 904893125, win 65495, options [mss 65495,sackOK,TS val 4026038040 ecr 0,nop,wscale 7,mptcp capable v1], length 0}
\PYG{g+go}{18:43:42.676426 IP 127.0.0.1.12345 \PYGZgt{} 127.0.0.1.52854: Flags [S.], seq 1804351310, ack 904893126, win 65483, options [mss 65495,sackOK,TS val 4026038040 ecr 4026038040,nop,wscale 7,mptcp capable v1 \PYGZob{}0x45edb502d861e7b1\PYGZcb{}], length 0}
\PYG{g+go}{18:43:42.676472 IP 127.0.0.1.52854 \PYGZgt{} 127.0.0.1.12345: Flags [.], ack 1, win 512, options [nop,nop,TS val 4026038040 ecr 4026038040,mptcp capable v1 \PYGZob{}0xdbb760db1d55e07b,0x45edb502d861e7b1\PYGZcb{}], length 0}
\PYG{g+go}{18:44:59.519697 IP 127.0.0.1.52854 \PYGZgt{} 127.0.0.1.12345: Flags [P.], seq 1:13, ack 1, win 512, options [nop,nop,TS val 4026114884 ecr 4026038040,mptcp capable v1 \PYGZob{}0xdbb760db1d55e07b,0x45edb502d861e7b1\PYGZcb{},nop,nop], length 12}
\PYG{g+go}{18:44:59.519755 IP 127.0.0.1.12345 \PYGZgt{} 127.0.0.1.52854: Flags [.], ack 13, win 512, options [nop,nop,TS val 4026114884 ecr 4026114884,mptcp dss ack 16040019788386937262], length 0}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first packet is the \sphinxcode{\sphinxupquote{SYN}} that includes the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option. The server replies with the \sphinxcode{\sphinxupquote{SYN+ACK}} with the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} containing the server key. The client returns the third \sphinxcode{\sphinxupquote{ACK}} with the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} and the two keys. As the server did not send any data, the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option is sent again in the packet containing the \sphinxcode{\sphinxupquote{Simple test}} string. This packet also contains the \sphinxcode{\sphinxupquote{DSS}} option. The server replies with an acknowledgment that carries the \sphinxcode{\sphinxupquote{DSS}} option.

\sphinxAtStartPar
We can now use the netcat application to explore the operation of Multipath TCP over the Internet. Let us start with a very simple example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{mptcpize run nc serverv4 12345}
\PYG{g+go}{hello}
\end{sphinxVerbatim}

\sphinxAtStartPar
The netcat process listens on port 12345 on the server. This results in the following Multipath TCP connection :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{09:05:23.695876 IP host\PYGZhy{}78\PYGZhy{}129\PYGZhy{}5\PYGZhy{}171.dynamic.voo.be.41510 \PYGZgt{} serverv4.12345: Flags [S], seq 3525674027, win 64240, options [mss 1460,sackOK,TS val 2619832768 ecr 0,nop,wscale 7,mptcp capable v1], length 0}
\PYG{g+go}{09:05:23.696076 IP serverv4.12345 \PYGZgt{} host\PYGZhy{}78\PYGZhy{}129\PYGZhy{}5\PYGZhy{}171.dynamic.voo.be.41510: Flags [S.], seq 1745741580, ack 3525674028, win 65160, options [mss 1460,sackOK,TS val 3069340264 ecr 2619832768,nop,wscale 7,mptcp capable v1 \PYGZob{}0x82aa42ef4245f0d0\PYGZcb{}], length 0}
\PYG{g+go}{09:05:23.707909 IP host\PYGZhy{}78\PYGZhy{}129\PYGZhy{}5\PYGZhy{}171.dynamic.voo.be.41510 \PYGZgt{} serverv4.12345: Flags [.], ack 1, win 502, options [nop,nop,TS val 2619832783 ecr 3069340264,mptcp capable v1 \PYGZob{}0x9dc8e3972e3d9f25,0x82aa42ef4245f0d0\PYGZcb{}], length 0}
\PYG{g+go}{09:05:30.776312 IP host\PYGZhy{}78\PYGZhy{}129\PYGZhy{}5\PYGZhy{}171.dynamic.voo.be.41510 \PYGZgt{} serverv4.12345: Flags [P.], seq 1:7, ack 1, win 502, options [nop,nop,TS val 2619839851 ecr 3069340264,mptcp capable v1 \PYGZob{}0x9dc8e3972e3d9f25,0x82aa42ef4245f0d0\PYGZcb{},nop,nop], length 6}
\PYG{g+go}{09:05:30.776484 IP serverv4.12345 \PYGZgt{} host\PYGZhy{}78\PYGZhy{}129\PYGZhy{}5\PYGZhy{}171.dynamic.voo.be.41510: Flags [.], ack 7, win 510, options [nop,nop,TS val 3069347345 ecr 2619839851,mptcp dss ack 1561335003985645838], length 0}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a Multipath TCP connection since it includes the Multipath TCP options, but the client does not create an additional subflow and the server does not announce its other addresses. This is the expected behavior since these operations are controlled by the path manager. On Linux, the Multipath TCP path manager can be configured using the \sphinxhref{https://man7.org/linux/man-pages/man8/ip-mptcp.8.html}{ip\sphinxhyphen{}mptcp} command. This command can be used to configure different parameters that are associated to an IP address. The path manager associates a numeric identifier to each IP address or endpoint. The \sphinxcode{\sphinxupquote{ip mptcp endpoint show}} command lists the identifiers of the active IP addresses on the host. Here is an example of the output of this command on our client:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ip mptcp endpoint show}
\PYG{g+go}{fe80::3934:7572:b1ff:b555 id 1 dev wlp3s0}
\PYG{g+go}{192.168.0.43 id 2 dev wlp3s0}
\PYG{g+go}{fe80::5642:39bd:3390:43d3 id 3 dev enp2s0}
\PYG{g+go}{192.168.0.37 id 4 dev enp2s0}
\PYG{g+go}{2a02:2788:10c4:123:3d66:f590:d891:8fb3 id 5 dev wlp3s0}
\PYG{g+go}{2a02:2788:10c4:123:6636:10c6:692b:18cc id 6 dev enp2s0}
\PYG{g+go}{2a02:2788:10c4:123:2a09:5ec7:9b99:4a97 id 7 dev enp2s0}
\end{sphinxVerbatim}

\sphinxAtStartPar
The two \sphinxcode{\sphinxupquote{fe80}} addresses are the IPv6 link local addresses configured on the Ethernet (\sphinxcode{\sphinxupquote{enp2s0}}) and Wi\sphinxhyphen{}Fi (\sphinxcode{\sphinxupquote{wlp3s0}}) interfaces of our client host. There are three flags which can be associated with each endpoint identifier:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subflow}}. When this flag is set, the path manager will try to create a subflow over this interface when a Multipath TCP is created or the interface becomes active while there was an ongoing Multipath TCP connection. This flag is mainly useful for clients.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{signal}}. When this flag is set, the path manager will announce the address of the endpoint over any Multipath TCP connection created using other addresses. This flag can be used on clients or servers. It is mainly useful on servers that have multiple addresses.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{backup}}. This flag can be combined with the two other flags. When combined with the \sphinxcode{\sphinxupquote{subflow}} flag, it indicates that a backup subflow will be created. When combined with the \sphinxcode{\sphinxupquote{signal}} flag, it indicates that the address will be advertised as a backup address.

\end{itemize}

\sphinxAtStartPar
On our client host, we can configure the Wi\sphinxhyphen{}Fi interface as a backup interface that creates subflows as follows :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo ip mptcp endpoint del id 2}
\PYG{g+go}{sudo ip mptcp endpoint add 192.168.0.43 dev wlp3s0 subflow backup}
\PYG{g+go}{sudo ip mptcp endpoint show}
\PYG{g+go}{fe80::3934:7572:b1ff:b555 id 1 dev wlp3s0}
\PYG{g+go}{fe80::5642:39bd:3390:43d3 id 3 dev enp2s0}
\PYG{g+go}{192.168.0.37 id 4 dev enp2s0}
\PYG{g+go}{2a02:2788:10c4:123:3d66:f590:d891:8fb3 id 5 dev wlp3s0}
\PYG{g+go}{2a02:2788:10c4:123:6636:10c6:692b:18cc id 6 dev enp2s0}
\PYG{g+go}{2a02:2788:10c4:123:2a09:5ec7:9b99:4a97 id 7 dev enp2s0}
\PYG{g+go}{192.168.0.43 id 8 subflow backup dev wlp3s0}
\end{sphinxVerbatim}

\sphinxAtStartPar
We had to first remove the configuration for this endpoint because a default one was already active. Then we added the new parameters and verified them.

\sphinxAtStartPar
The path manager also has some limits which can be configured using the \sphinxcode{\sphinxupquote{ip mptcp limits}} command. Two limits can be set.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ip mptcp limits set subflow n}} where \sphinxcode{\sphinxupquote{n}} is an integer. This restricts the Multipath TCP connection to use up to \sphinxcode{\sphinxupquote{n}} different subflows. Servers should protect themselves by setting this limit to a few subflows. Most use cases would work well with 2 or 4 subflows.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ip mptcp limits set add\_addr\_accepted n}} where \sphinxcode{\sphinxupquote{n}} is an integer. This parameter limits the number of addresses that are learned over each Multipath TCP connection. This parameter could be used to protect the Multipath TCP implementation against attacks where two many addresses are advertised. Most use cases would work with 4 accepted addresses.

\end{itemize}

\sphinxAtStartPar
These parameters control the path manager, but before creating Multipath TCP subflows over different paths, we need to configure the IP routing table of our client host. Our client host has two network interfaces: Wi\sphinxhyphen{}Fi and Ethernet. By default, Linux prefers the Ethernet interface to Wi\sphinxhyphen{}Fi. The two interfaces are configured as follows :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ip \PYGZhy{}4 addr show}
\PYG{g+go}{1: lo: \PYGZlt{}LOOPBACK,UP,LOWER\PYGZus{}UP\PYGZgt{} mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000}
\PYG{g+go}{    inet 127.0.0.1/8 scope host lo}
\PYG{g+go}{    valid\PYGZus{}lft forever preferred\PYGZus{}lft forever}
\PYG{g+go}{2: enp2s0: \PYGZlt{}BROADCAST,MULTICAST,UP,LOWER\PYGZus{}UP\PYGZgt{} mtu 1500 qdisc fq\PYGZus{}codel state UP group default qlen 1000}
\PYG{g+go}{    inet 192.168.0.37/24 brd 192.168.0.255 scope global dynamic noprefixroute enp2s0}
\PYG{g+go}{    valid\PYGZus{}lft 75697sec preferred\PYGZus{}lft 75697sec}
\PYG{g+go}{3: wlp3s0: \PYGZlt{}BROADCAST,MULTICAST,UP,LOWER\PYGZus{}UP\PYGZgt{} mtu 1500 qdisc noqueue state UP group default qlen 1000}
\PYG{g+go}{    inet 192.168.0.43/24 brd 192.168.0.255 scope global dynamic noprefixroute wlp3s0}
\PYG{g+go}{    valid\PYGZus{}lft 75696sec preferred\PYGZus{}lft 75696sec}
\end{sphinxVerbatim}

\sphinxAtStartPar
By default, Linux creates the two following default routes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{route \PYGZhy{}n}
\PYG{g+go}{Kernel IP routing table}
\PYG{g+go}{Destination     Gateway         Genmask         Flags Metric Ref    Use Iface}
\PYG{g+go}{0.0.0.0         192.168.0.1     0.0.0.0         UG    100    0        0 enp2s0}
\PYG{g+go}{0.0.0.0         192.168.0.1     0.0.0.0         UG    600    0        0 wlp3s0}
\end{sphinxVerbatim}

\sphinxAtStartPar
We need to configure the routing tables to be able to use the two interfaces simultaneously. For this, we need to ensure that packets with source address \sphinxcode{\sphinxupquote{192.168.0.37}} are sent over the \sphinxcode{\sphinxupquote{enp2s0}} interface while packets with source address \sphinxcode{\sphinxupquote{192.168.0.43}} are sent over the \sphinxcode{\sphinxupquote{wlp3s0}} interface. This can be achieved using two different routing tables.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{} }create the two routing tables
\PYG{g+go}{ip rule add from 192.168.0.37 table 1}
\PYG{g+go}{ip rule add from 192.168.0.43 table 2}

\PYG{g+gp}{\PYGZsh{} }Configure routing table \PYG{l+m}{1} \PYG{k}{for} enp2s0
\PYG{g+go}{ip route add 192.168.0.0/24 dev enp2s0 scope link table 1}
\PYG{g+go}{ip route add default via 192.168.0.1 dev enp2s0 table 1}

\PYG{g+gp}{\PYGZsh{} }Configure routing table \PYG{l+m}{2} \PYG{k}{for} wlp3s0
\PYG{g+go}{ip route add 192.168.0.0/24 dev wlp3s0 scope link table 2}
\PYG{g+go}{ip route add default via 192.168.0.1 dev wlp3s0 table 2}

\PYG{g+gp}{\PYGZsh{} }Configure a default route to regular internet
\PYG{g+go}{ip route add default scope global nexthop via 192.168.0.1 dev enp2s0}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can check the routing tables using the ip command.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ip rule show}
\PYG{g+go}{0:   from all lookup local}
\PYG{g+go}{32764:       from 192.168.0.43 lookup 2}
\PYG{g+go}{32765:       from 192.168.0.37 lookup 1}
\PYG{g+go}{32766:       from all lookup main}
\PYG{g+go}{32767:       from all lookup default}

\PYG{g+go}{ip route}
\PYG{g+go}{default via 192.168.0.1 dev enp2s0}
\PYG{g+go}{default via 192.168.0.1 dev enp2s0 proto dhcp metric 100}
\PYG{g+go}{default via 192.168.0.1 dev wlp3s0 proto dhcp metric 600}
\PYG{g+go}{169.254.0.0/16 dev wlp3s0 scope link metric 1000}
\PYG{g+go}{192.168.0.0/24 dev enp2s0 proto kernel scope link src 192.168.0.37 metric 100}
\PYG{g+go}{192.168.0.0/24 dev wlp3s0 proto kernel scope link src 192.168.0.43 metric 600}

\PYG{g+go}{ip route show table 1}
\PYG{g+go}{default via 192.168.0.1 dev enp2s0}
\PYG{g+go}{192.168.0.0/24 dev enp2s0 scope link}

\PYG{g+go}{ip route show table 2}
\PYG{g+go}{default via 192.168.0.1 dev wlp3s0}
\PYG{g+go}{192.168.0.0/24 dev wlp3s0 scope link}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can verify that the two routing tables are correct using \sphinxcode{\sphinxupquote{nc}} by forcing it to use a specific source address.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{echo \PYGZhy{}e \PYGZdq{}GET / HTTP/1.0\PYGZbs{}r\PYGZbs{}n\PYGZdq{} | nc \PYGZhy{}4 \PYGZhy{}s 192.168.0.37 test.multipath\PYGZhy{}tcp.org 80}
\PYG{g+go}{HTTP/1.0 200 OK}
\PYG{g+go}{Content\PYGZhy{}Type: text/html}
\PYG{g+go}{ETag: \PYGZdq{}4215149735\PYGZdq{}}
\PYG{g+go}{Last\PYGZhy{}Modified: Tue, 05 Jul 2022 16:11:47 GMT}
\PYG{g+go}{Content\PYGZhy{}Length: 389}
\PYG{g+go}{Connection: close}
\PYG{g+go}{Date: Wed, 06 Jul 2022 11:34:24 GMT}
\PYG{g+go}{Server: lighttpd/1.4.59}

\PYG{g+go}{\PYGZlt{}!DOCTYPE html\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}html\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}head\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}title\PYGZgt{}Welcome to test.multipath\PYGZhy{}tcp.org!\PYGZlt{}/title\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}style\PYGZgt{}}
\PYG{g+go}{body \PYGZob{}}
\PYG{g+go}{width: 35em;}
\PYG{g+go}{margin: 0 auto;}
\PYG{g+go}{font\PYGZhy{}family: Tahoma, Verdana, Arial, sans\PYGZhy{}serif;}
\PYG{g+go}{\PYGZcb{}}
\PYG{g+go}{\PYGZlt{}/style\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}/head\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}body\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}h1\PYGZgt{}Welcome to test.multipath\PYGZhy{}tcp.org !\PYGZlt{}/h1\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}p\PYGZgt{}This web server runs Multipath TCP v1\PYGZlt{}/p\PYGZgt{}}

\PYG{g+go}{\PYGZlt{}p\PYGZgt{}\PYGZlt{}em\PYGZgt{}Thank you for using Multipath TCP.\PYGZlt{}/em\PYGZgt{}\PYGZlt{}/p\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}/body\PYGZgt{}}
\PYG{g+go}{\PYGZlt{}/html\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You should get the same result when using the second interface, IP address \sphinxcode{\sphinxupquote{192.168.0.43}} in our example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{echo \PYGZhy{}e \PYGZdq{}GET / HTTP/1.0\PYGZbs{}r\PYGZbs{}n\PYGZdq{} | nc \PYGZhy{}4 \PYGZhy{}s 192.168.0.43 test.multipath\PYGZhy{}tcp.org 80}
\end{sphinxVerbatim}

\sphinxAtStartPar
The next step is to verify that Multipath TCP is working correctly and that two subflows are created. For this, we’ll use the \sphinxcode{\sphinxupquote{\sphinxhyphen{}i}} parameter of \sphinxcode{\sphinxupquote{nc}} to add a delay between the two lines of the HTTP GET. We will leverage this delay to check that MPTCP is correctly working using \sphinxcode{\sphinxupquote{ss}} or \sphinxcode{\sphinxupquote{tcpdump}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{echo \PYGZhy{}e \PYGZdq{}GET / HTTP/1.0\PYGZbs{}r\PYGZbs{}n\PYGZdq{} | mptcpize run nc \PYGZhy{}4 \PYGZhy{}i 5 test.multipath\PYGZhy{}tcp.org 80}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can observe the creation of the connection and the subflow using both \sphinxcode{\sphinxupquote{ss}} and \sphinxcode{\sphinxupquote{tcpdump}}. \sphinxcode{\sphinxupquote{ss}} shows that there are two subflows towards \sphinxcode{\sphinxupquote{test.multipath\sphinxhyphen{}tcp.org}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ss \PYGZhy{}4 \PYGZhy{}iatM  dst test.multipath\PYGZhy{}tcp.org}
\PYG{g+go}{Netid  State  Recv\PYGZhy{}Q  Send\PYGZhy{}Q         Local Address:Port      Peer Address:Port  Process}
\PYG{g+go}{tcp    ESTAB  0       0        192.168.0.43\PYGZpc{}wlp3s0:34801     5.196.67.207:http}
\PYG{g+go}{      cubic wscale:7,7 rto:220 rtt:17.439/8.719 mss:1448 pmtu:1500 rcvmss:536 advmss:1448 cwnd:10 bytes\PYGZus{}acked:1 segs\PYGZus{}out:2 segs\PYGZus{}in:2 send 6.64Mbps lastsnd:1776 lastrcv:1776 lastack:1764 pacing\PYGZus{}rate 13.3Mbps delivered:1 rcv\PYGZus{}space:14480 rcv\PYGZus{}ssthresh:64088 minrtt:17.439}
\PYG{g+go}{tcp    ESTAB  0       0               192.168.0.37:47672     5.196.67.207:http}
\PYG{g+go}{      cubic wscale:7,7 rto:216 rtt:14/5.405 mss:1448 pmtu:1500 rcvmss:536 advmss:1448 cwnd:10 bytes\PYGZus{}sent:16 bytes\PYGZus{}acked:17 segs\PYGZus{}out:3 segs\PYGZus{}in:3 data\PYGZus{}segs\PYGZus{}out:1 send 8.27Mbps lastsnd:1808 lastrcv:1808 lastack:1792 pacing\PYGZus{}rate 16.5Mbps delivery\PYGZus{}rate 790kbps delivered:2 busy:16ms rcv\PYGZus{}space:14480 rcv\PYGZus{}ssthresh:64088 minrtt:13.905}
\PYG{g+go}{mptcp  ESTAB  0       0               192.168.0.37:47672     5.196.67.207:http}
\PYG{g+go}{      subflows:1 subflows\PYGZus{}max:8 remote\PYGZus{}key token:e1e3cdeb write\PYGZus{}seq:1045ecfa3f05f4ea snd\PYGZus{}una:1045ecfa3f05f4ea rcv\PYGZus{}nxt:d0568f430363c9aa}
\end{sphinxVerbatim}

\sphinxAtStartPar
The line starting with \sphinxcode{\sphinxupquote{mptcp}} indicates that the Multipath TCP connection above has one additional subflow.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{tcpdump}} output reveals precisely which packets have been sent over each network interface.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo tcpdump \PYGZhy{}n \PYGZhy{}i any host test.multipath\PYGZhy{}tcp.org and port 80tcpdump: data link type LINUX\PYGZus{}SLL2}
\PYG{g+go}{tcpdump: verbose output suppressed, use \PYGZhy{}v[v]... for full protocol decode}
\PYG{g+go}{listening on any, link\PYGZhy{}type LINUX\PYGZus{}SLL2 (Linux cooked v2), snapshot length 262144 bytes}
\PYG{g+go}{13:43:26.620667 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [S], seq 3585891423, win 64240, options [mss 1460,sackOK,TS val 3993892549 ecr 0,nop,wscale 7,mptcp capable v1], length 0}
\PYG{g+go}{13:43:26.634537 enp2s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.37.47672: Flags [S.], seq 1788691420, ack 3585891424, win 65160, options [mss 1460,sackOK,TS val 1030255900 ecr 3993892549,nop,wscale 7,mptcp capable v1 \PYGZob{}0x54f04ad5bd2d9f42\PYGZcb{}], length 0}
\PYG{g+go}{13:43:26.634609 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 1, win 502, options [nop,nop,TS val 3993892563 ecr 1030255900,mptcp capable v1 \PYGZob{}0xff2ec3a2f6151881,0x54f04ad5bd2d9f42\PYGZcb{}], length 0}
\PYG{g+go}{13:43:26.634718 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [P.], seq 1:17, ack 1, win 502, options [nop,nop,TS val 3993892563 ecr 1030255900,mptcp capable v1 \PYGZob{}0xff2ec3a2f6151881,0x54f04ad5bd2d9f42\PYGZcb{},nop,nop], length 16: HTTP: GET / HTTP/1.0}
\PYG{g+go}{13:43:26.649351 enp2s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.37.47672: Flags [.], ack 17, win 509, options [nop,nop,TS val 1030255916 ecr 3993892563,mptcp dss ack 1172603837543216362], length 0}
\PYG{g+go}{13:43:26.649351 enp2s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.37.47672: Flags [.], ack 17, win 509, options [nop,nop,TS val 1030255916 ecr 3993892563,mptcp dss ack 1172603837543216362], length 0}
\PYG{g+go}{13:43:26.649498 wlp3s0 Out IP 192.168.0.43.34801 \PYGZgt{} 5.196.67.207.80: Flags [S], seq 2321572505, win 64240, options [mss 1460,sackOK,TS val 1218002018 ecr 0,nop,wscale 7,mptcp join id 8 token 0xeef7df2f nonce 0xc0d346f6], length 0}
\PYG{g+go}{13:43:26.666895 wlp3s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.43.34801: Flags [S.], seq 1973196884, ack 2321572506, win 65160, options [mss 1460,sackOK,TS val 1030255931 ecr 1218002018,nop,wscale 7,mptcp join id 0 hmac 0xc7489cf7056428b4 nonce 0xa54f9af], length 0}
\PYG{g+go}{13:43:26.666966 wlp3s0 Out IP 192.168.0.43.34801 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 1, win 502, options [nop,nop,TS val 1218002035 ecr 1030255931,mptcp join hmac 0xb4e6a41bf5861313df7f5f454966998ad7e698a4], length 0}
\PYG{g+go}{13:43:26.677776 wlp3s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.43.34801: Flags [.], ack 1, win 510, options [nop,nop,TS val 1030255944 ecr 1218002035,mptcp dss ack 1172603837543216362], length 0}
\PYG{g+go}{13:43:31.635023 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [P.], seq 17:18, ack 1, win 502, options [nop,nop,TS val 3993897563 ecr 1030255916,mptcp dss ack 56871338 seq 1172603837543216362 subseq 17 len 1,nop,nop], length 1: HTTP}
\PYG{g+go}{13:43:31.646703 enp2s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.37.47672: Flags [.], ack 18, win 509, options [nop,nop,TS val 1030260913 ecr 3993897563,mptcp dss ack 1172603837543216363], length 0}
\PYG{g+go}{13:43:31.647276 enp2s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.37.47672: Flags [P.], seq 1:602, ack 18, win 509, options [nop,nop,TS val 1030260914 ecr 3993897563,mptcp dss ack 1172603837543216363 seq 15012343925868579242 subseq 1 len 601,nop,nop], length 601: HTTP: HTTP/1.0 200 OK}
\PYG{g+go}{13:43:31.647300 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 602, win 501, options [nop,nop,TS val 3993897576 ecr 1030260914,mptcp dss ack 15012343925868579843], length 0}
\PYG{g+go}{13:43:31.647276 enp2s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.37.47672: Flags [.], ack 18, win 509, options [nop,nop,TS val 1030260914 ecr 3993897563,mptcp dss fin ack 1172603837543216363 seq 15012343925868579843 subseq 0 len 1,nop,nop], length 0}
\PYG{g+go}{13:43:31.647321 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 602, win 501, options [nop,nop,TS val 3993897576 ecr 1030260914,mptcp dss ack 15012343925868579844], length 0}
\PYG{g+go}{13:43:31.647330 wlp3s0 Out IP 192.168.0.43.34801 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 1, win 502, options [nop,nop,TS val 1218002046 ecr 1030255944,mptcp dss ack 15012343925868579844], length 0}
\PYG{g+go}{13:43:31.648565 wlp3s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.43.34801: Flags [.], ack 1, win 510, options [nop,nop,TS val 1030255944 ecr 1218002035,mptcp dss fin ack 1172603837543216363 seq 15012343925868579843 subseq 0 len 1,nop,nop], length 0}
\PYG{g+go}{13:43:36.635392 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 602, win 501, options [nop,nop,TS val 3993897576 ecr 1030260914,mptcp dss fin ack 15012343925868579844 seq 1172603837543216363 subseq 0 len 1,nop,nop], length 0}
\PYG{g+go}{13:43:36.635416 wlp3s0 Out IP 192.168.0.43.34801 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 1, win 502, options [nop,nop,TS val 1218007017 ecr 1030255944,mptcp dss fin ack 15012343925868579844 seq 1172603837543216363 subseq 0 len 1,nop,nop], length 0}
\PYG{g+go}{13:43:36.636468 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 602, win 501, options [nop,nop,TS val 3993897576 ecr 1030260914,mptcp dss fin ack 15012343925868579844 seq 1172603837543216363 subseq 0 len 1,nop,nop], length 0}
\PYG{g+go}{13:43:36.636482 wlp3s0 Out IP 192.168.0.43.34801 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 1, win 502, options [nop,nop,TS val 1218007017 ecr 1030255944,mptcp dss fin ack 15012343925868579844 seq 1172603837543216363 subseq 0 len 1,nop,nop], length 0}
\PYG{g+go}{13:43:36.640425 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 602, win 501, options [nop,nop,TS val 3993897576 ecr 1030260914,mptcp dss fin ack 15012343925868579844 seq 1172603837543216363 subseq 0 len 1,nop,nop], length 0}
\PYG{g+go}{13:43:36.640431 wlp3s0 Out IP 192.168.0.43.34801 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 1, win 502, options [nop,nop,TS val 1218007017 ecr 1030255944,mptcp dss fin ack 15012343925868579844 seq 1172603837543216363 subseq 0 len 1,nop,nop], length 0}
\PYG{g+go}{13:43:36.645605 enp2s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.37.47672: Flags [.], ack 18, win 509, options [nop,nop,TS val 1030265912 ecr 3993897576,mptcp dss ack 1172603837543216364], length 0}
\PYG{g+go}{13:43:36.645659 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [F.], seq 18, ack 602, win 501, options [nop,nop,TS val 3993902574 ecr 1030265912,mptcp dss ack 15012343925868579844], length 0}
\PYG{g+go}{13:43:36.645674 wlp3s0 Out IP 192.168.0.43.34801 \PYGZgt{} 5.196.67.207.80: Flags [F.], seq 1, ack 1, win 502, options [nop,nop,TS val 1218012014 ecr 1030255944,mptcp dss ack 15012343925868579844], length 0}
\PYG{g+go}{13:43:36.646315 wlp3s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.43.34801: Flags [.], ack 1, win 510, options [nop,nop,TS val 1030260930 ecr 1218002046,mptcp dss ack 1172603837543216364], length 0}
\PYG{g+go}{13:43:36.647699 enp2s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.37.47672: Flags [F.], seq 602, ack 18, win 509, options [nop,nop,TS val 1030265912 ecr 3993897576,mptcp dss ack 1172603837543216364], length 0}
\PYG{g+go}{13:43:36.647718 enp2s0 Out IP 192.168.0.37.47672 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 603, win 501, options [nop,nop,TS val 3993902576 ecr 1030265912,mptcp dss ack 15012343925868579844], length 0}
\PYG{g+go}{13:43:36.648629 wlp3s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.43.34801: Flags [F.], seq 1, ack 1, win 510, options [nop,nop,TS val 1030265912 ecr 1218002046,mptcp dss ack 1172603837543216364], length 0}
\PYG{g+go}{13:43:36.648649 wlp3s0 Out IP 192.168.0.43.34801 \PYGZgt{} 5.196.67.207.80: Flags [.], ack 2, win 502, options [nop,nop,TS val 1218012017 ecr 1030265912,mptcp dss ack 15012343925868579844], length 0}
\PYG{g+go}{13:43:36.657040 enp2s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.37.47672: Flags [.], ack 19, win 509, options [nop,nop,TS val 1030265923 ecr 3993902574,mptcp dss ack 1172603837543216364], length 0}
\PYG{g+go}{13:43:36.662211 wlp3s0 In  IP 5.196.67.207.80 \PYGZgt{} 192.168.0.43.34801: Flags [.], ack 2, win 510, options [nop,nop,TS val 1030265928 ecr 1218012014,mptcp dss ack 1172603837543216364], length 0}
\end{sphinxVerbatim}

\sphinxAtStartPar
If your host is dual stack, you also need to do the same configuration for IPv6 as well. Our test host uses the following IPv6 addresses.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ip \PYGZhy{}6 addr show}
\PYG{g+go}{1: lo: \PYGZlt{}LOOPBACK,UP,LOWER\PYGZus{}UP\PYGZgt{} mtu 65536 state UNKNOWN qlen 1000}
\PYG{g+go}{    inet6 ::1/128 scope host}
\PYG{g+go}{    valid\PYGZus{}lft forever preferred\PYGZus{}lft forever}
\PYG{g+go}{2: enp2s0: \PYGZlt{}BROADCAST,MULTICAST,UP,LOWER\PYGZus{}UP\PYGZgt{} mtu 1500 state UP qlen 1000}
\PYG{g+go}{    inet6 2a02:2788:10c4:123:f468:1851:9a9f:7d44/64 scope global temporary dynamic}
\PYG{g+go}{    valid\PYGZus{}lft 592298sec preferred\PYGZus{}lft 73422sec}
\PYG{g+go}{    inet6 2a02:2788:10c4:123:6636:10c6:692b:18cc/64 scope global dynamic mngtmpaddr noprefixroute}
\PYG{g+go}{    valid\PYGZus{}lft 1209600sec preferred\PYGZus{}lft 604800sec}
\PYG{g+go}{    inet6 fe80::5642:39bd:3390:43d3/64 scope link noprefixroute}
\PYG{g+go}{    valid\PYGZus{}lft forever preferred\PYGZus{}lft forever}
\PYG{g+go}{3: wlp3s0: \PYGZlt{}BROADCAST,MULTICAST,UP,LOWER\PYGZus{}UP\PYGZgt{} mtu 1500 state UP qlen 1000}
\PYG{g+go}{    inet6 2a02:2788:10c4:123:3d66:f590:d891:8fb3/64 scope global dynamic noprefixroute}
\PYG{g+go}{    valid\PYGZus{}lft 1209600sec preferred\PYGZus{}lft 604800sec}
\PYG{g+go}{    inet6 fe80::3934:7572:b1ff:b555/64 scope link noprefixroute}
\PYG{g+go}{    valid\PYGZus{}lft forever preferred\PYGZus{}lft forever}
\end{sphinxVerbatim}

\sphinxAtStartPar
We thus had to configure the following IPv6 routing tables. This is similar to the commands used to configure the IPv4 routing tables.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ip \PYGZhy{}6 rule add from 2a02:2788:10c4:123:6636:10c6:692b:18cc table 1}
\PYG{g+go}{ip \PYGZhy{}6 rule add from 2a02:2788:10c4:123:3d66:f590:d891:8fb3 table 2}
\PYG{g+go}{ip route add 2a02:2788:10c4:123::/64 dev enp2s0 scope link table 1}
\PYG{g+go}{ip route add 2a02:2788:10c4:123::/64 dev wlp3s0 scope link table 2}
\PYG{g+go}{ip route add default via fe80::10:18ff:fe07:fc33 dev enp2s0 table 1}
\PYG{g+go}{ip route add default via fe80::10:18ff:fe07:fc33 dev wlp3s0 table 2}
\PYG{g+go}{ip route add default scope global nexthop via fe80::10:18ff:fe07:fc33 dev enp2s0}
\end{sphinxVerbatim}

\sphinxAtStartPar
Remember that if you want to create subflows using IPv6 addresses, you also need to configure the stack with \sphinxcode{\sphinxupquote{ip mptcp endpoint add}} as you did for the IPv4 addresses.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The current versions of the Linux kernel only use one address family at a time. If a connection was created using IPv4, then only IPv4 addresses will be used to create new subflows. Future versions of the kernel will allow to mix IPv4 and IPv6 subflows.
\end{sphinxadmonition}


\section{Analyzing the output of ss}
\label{\detokenize{mptcp-linux:analyzing-the-output-of-ss}}

\chapter{Analyzing the output of nstat}
\label{\detokenize{nstat-intro:analyzing-the-output-of-nstat}}\label{\detokenize{nstat-intro::doc}}
\sphinxAtStartPar
The Linux TCP/IP stack maintains a lot of counters that track various
events inside the kernel. These counters are very useful for system
administrators who need to manage Linux hosts and debug some specific
networking problems.

\sphinxAtStartPar
Linux supports a few hundred counters associated to the protocols in the
network and transport layers. Other operating systems have defined their
own counters to track similar networking events. Fortunately, the IETF
has standard some counters that are common to different operating
systems and TCP/IP implementations. These counters are exported as
variables which can be queried using a management protocol such as SNMP.
This enables a management server to collect statistics for a series of
hosts to process and analyze them.  Several versions of SNMP exist, but
we will not discuss them in details in this document. Instead, we
focus on the Linux TCP/IP implementation and explain the different counters
that the \sphinxhref{https://www.man7.org/linux/man-pages/man8/nstat.8.html}{nstat}
application exposes to the user.

\sphinxAtStartPar
Linux kernel version 5.18 collects 363 different counters that are divided in 7 categories :
\begin{itemize}
\item {} 
\sphinxAtStartPar
67 counters track the IPv4 implementation

\item {} 
\sphinxAtStartPar
80 counters track the ICMPv4 implementation

\item {} 
\sphinxAtStartPar
32 counters track the IPv6 implementation

\item {} 
\sphinxAtStartPar
46 counters track ICMPv6

\item {} 
\sphinxAtStartPar
135 counters track TCP

\item {} 
\sphinxAtStartPar
35 counters track UDP

\item {} 
\sphinxAtStartPar
46 counters track Multipath TCP

\end{itemize}

\sphinxAtStartPar
Some of these counters are part of the Management Information Bases (MIB) defined
within the IETF, e.g. \index{RFC@\spxentry{RFC}!RFC 1213@\spxentry{RFC 1213}}\sphinxhref{https://tools.ietf.org/html/rfc1213.html}{\sphinxstylestrong{RFC 1213}} for IPv4 and ICMPv4, \index{RFC@\spxentry{RFC}!RFC 4293@\spxentry{RFC 4293}}\sphinxhref{https://tools.ietf.org/html/rfc4293.html}{\sphinxstylestrong{RFC 4293}} for IPv6 and ICMPv6,  \index{RFC@\spxentry{RFC}!RFC 4022@\spxentry{RFC 4022}}\sphinxhref{https://tools.ietf.org/html/rfc4022.html}{\sphinxstylestrong{RFC 4022}} for TCP, \index{RFC@\spxentry{RFC}!RFC 4113@\spxentry{RFC 4113}}\sphinxhref{https://tools.ietf.org/html/rfc4113.html}{\sphinxstylestrong{RFC 4113}} for UDP. As of this writing, there is no official IETF MIB for Multipath TCP.


\section{Using nstat}
\label{\detokenize{nstat-intro:using-nstat}}
\sphinxAtStartPar
In this document, we describe the counters that are exposed by
\sphinxhref{https://www.man7.org/linux/man-pages/man8/nstat.8.html}{nstat}
for the different protocols of the TCP/IP stack. Before discussing
these counters, it is useful to understand how
\sphinxhref{https://www.man7.org/linux/man-pages/man8/nstat.8.html}{nstat} works.

\sphinxAtStartPar
\sphinxhref{https://www.man7.org/linux/man-pages/man8/nstat.8.html}{nstat} is a
command line tool that supports a small number of arguments

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{nstat \PYGZhy{}\PYGZhy{}help}
\PYG{g+go}{Usage: nstat [OPTION] [ PATTERN [ PATTERN ] ]}
\PYG{g+go}{       \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            this message}
\PYG{g+go}{       \PYGZhy{}a, \PYGZhy{}\PYGZhy{}ignore  ignore history}
\PYG{g+go}{       \PYGZhy{}d, \PYGZhy{}\PYGZhy{}scan=SECS       sample every statistics every SECS}
\PYG{g+go}{       \PYGZhy{}j, \PYGZhy{}\PYGZhy{}json            format output in JSON}
\PYG{g+go}{       \PYGZhy{}n, \PYGZhy{}\PYGZhy{}nooutput        do history only}
\PYG{g+go}{       \PYGZhy{}p, \PYGZhy{}\PYGZhy{}pretty  pretty print}
\PYG{g+go}{       \PYGZhy{}r, \PYGZhy{}\PYGZhy{}reset           reset history}
\PYG{g+go}{       \PYGZhy{}s, \PYGZhy{}\PYGZhy{}noupdate        don\PYGZsq{}t update history}
\PYG{g+go}{       \PYGZhy{}t, \PYGZhy{}\PYGZhy{}interval=SECS   report average over the last SECS}
\PYG{g+go}{       \PYGZhy{}V, \PYGZhy{}\PYGZhy{}version output version information}
\PYG{g+go}{       \PYGZhy{}z, \PYGZhy{}\PYGZhy{}zeros           show entries with zero activity}
\end{sphinxVerbatim}

\sphinxAtStartPar
By default, \sphinxhref{https://www.man7.org/linux/man-pages/man8/nstat.8.html}{nstat}
displays the counters whose value has changed since the latest invocation
of the tool. This is usually a small subset of the counters
that depends on the networking activity of the host.

\sphinxAtStartPar
\sphinxhref{https://www.man7.org/linux/man-pages/man8/nstat.8.html}{nstat} can collect
historical information and provides average counters.

\sphinxAtStartPar
\sphinxhref{https://www.man7.org/linux/man-pages/man8/nstat.8.html}{nstat} can also list
the current value of the different counters.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}nstat \PYGZhy{}az
\PYG{g+gp}{       \PYGZsh{}}kernel
\PYG{g+go}{       IpInReceives                    1073367            0.0}
\PYG{g+go}{       IpInHdrErrors                   0                  0.0}
\PYG{g+go}{       IpInAddrErrors                  0                  0.0}
\PYG{g+go}{       IpForwDatagrams                 0                  0.0}
\PYG{g+go}{       IpInUnknownProtos               0                  0.0}
\PYG{g+go}{       IpInDiscards                    0                  0.0}
\PYG{g+go}{       IpInDelivers                    1072518            0.0}
\PYG{g+go}{       IpOutRequests                   484889             0.0}
\PYG{g+go}{       IpOutDiscards                   0                  0.0}
\PYG{g+go}{       IpOutNoRoutes                   0                  0.0}
\PYG{g+go}{       IpReasmTimeout                  0                  0.0}
\PYG{g+go}{       IpReasmReqds                    0                  0.0}
\PYG{g+go}{       IpReasmOKs                      0                  0.0}
\PYG{g+go}{       IpReasmFails                    0                  0.0}
\PYG{g+go}{       IpFragOKs                       0                  0.0}
\PYG{g+go}{       IpFragFails                     0                  0.0}
\PYG{g+go}{       IpFragCreates                   0                  0.0}
\PYG{g+go}{       IcmpInMsgs                      561                0.0}
\PYG{g+go}{       IcmpInErrors                    125                0.0}
\PYG{g+go}{       IcmpInCsumErrors                0                  0.0}
\PYG{g+go}{       IcmpInDestUnreachs              6                  0.0}
\PYG{g+go}{       IcmpInTimeExcds                 125                0.0}
\PYG{g+go}{       IcmpInParmProbs                 0                  0.0}
\PYG{g+go}{       IcmpInSrcQuenchs                0                  0.0}
\PYG{g+go}{       IcmpInRedirects                 0                  0.0}
\PYG{g+go}{       IcmpInEchos                     298                0.0}
\PYG{g+go}{       IcmpInEchoReps                  0                  0.0}
\PYG{g+go}{       IcmpInTimestamps                33                 0.0}
\PYG{g+go}{       IcmpInTimestampReps             0                  0.0}
\PYG{g+go}{       IcmpInAddrMasks                 99                 0.0}
\PYG{g+go}{       IcmpInAddrMaskReps              0                  0.0}
\PYG{g+go}{       IcmpOutMsgs                     331                0.0}
\PYG{g+go}{       IcmpOutErrors                   0                  0.0}
\PYG{g+go}{       IcmpOutDestUnreachs             0                  0.0}
\PYG{g+go}{       IcmpOutTimeExcds                0                  0.0}
\PYG{g+go}{       IcmpOutParmProbs                0                  0.0}
\PYG{g+go}{       IcmpOutSrcQuenchs               0                  0.0}
\PYG{g+go}{       IcmpOutRedirects                0                  0.0}
\PYG{g+go}{       IcmpOutEchos                    0                  0.0}
\PYG{g+go}{       IcmpOutEchoReps                 298                0.0}
\PYG{g+go}{       IcmpOutTimestamps               0                  0.0}
\PYG{g+go}{       IcmpOutTimestampReps            33                 0.0}
\PYG{g+go}{       IcmpOutAddrMasks                0                  0.0}
\PYG{g+go}{       IcmpOutAddrMaskReps             0                  0.0}
\PYG{g+go}{       IcmpMsgInType3                  6                  0.0}
\PYG{g+go}{       IcmpMsgInType8                  298                0.0}
\PYG{g+go}{       IcmpMsgInType11                 125                0.0}
\PYG{g+go}{       IcmpMsgInType13                 33                 0.0}
\PYG{g+go}{       IcmpMsgInType17                 99                 0.0}
\PYG{g+go}{       IcmpMsgOutType0                 298                0.0}
\PYG{g+go}{       IcmpMsgOutType14                33                 0.0}
\PYG{g+go}{       TcpActiveOpens                  3330               0.0}
\PYG{g+go}{       TcpPassiveOpens                 252                0.0}
\PYG{g+go}{       TcpAttemptFails                 0                  0.0}
\PYG{g+go}{       TcpEstabResets                  78                 0.0}
\PYG{g+go}{       TcpInSegs                       3202615            0.0}
\PYG{g+go}{       TcpOutSegs                      6431616            0.0}
\PYG{g+go}{       TcpRetransSegs                  7584               0.0}
\PYG{g+go}{       TcpInErrs                       0                  0.0}
\PYG{g+go}{       TcpOutRsts                      102                0.0}
\PYG{g+go}{       TcpInCsumErrors                 0                  0.0}
\PYG{g+go}{       UdpInDatagrams                  18972              0.0}
\PYG{g+go}{       UdpNoPorts                      0                  0.0}
\PYG{g+go}{       UdpInErrors                     0                  0.0}
\PYG{g+go}{       UdpOutDatagrams                 19257              0.0}
\PYG{g+go}{       UdpRcvbufErrors                 0                  0.0}
\PYG{g+go}{       UdpSndbufErrors                 0                  0.0}
\PYG{g+go}{       UdpInCsumErrors                 0                  0.0}
\PYG{g+go}{       UdpIgnoredMulti                 19989              0.0}
\PYG{g+go}{       UdpMemErrors                    0                  0.0}
\PYG{g+go}{       UdpLiteInDatagrams              0                  0.0}
\PYG{g+go}{       UdpLiteNoPorts                  0                  0.0}
\PYG{g+go}{       UdpLiteInErrors                 0                  0.0}
\PYG{g+go}{       UdpLiteOutDatagrams             0                  0.0}
\PYG{g+go}{       UdpLiteRcvbufErrors             0                  0.0}
\PYG{g+go}{       UdpLiteSndbufErrors             0                  0.0}
\PYG{g+go}{       UdpLiteInCsumErrors             0                  0.0}
\PYG{g+go}{       UdpLiteIgnoredMulti             0                  0.0}
\PYG{g+go}{       UdpLiteMemErrors                0                  0.0}
\PYG{g+go}{       Ip6InReceives                   2198489            0.0}
\PYG{g+go}{       Ip6InHdrErrors                  0                  0.0}
\PYG{g+go}{       Ip6InTooBigErrors               0                  0.0}
\PYG{g+go}{       Ip6InNoRoutes                   200                0.0}
\PYG{g+go}{       Ip6InAddrErrors                 0                  0.0}
\PYG{g+go}{       Ip6InUnknownProtos              0                  0.0}
\PYG{g+go}{       Ip6InTruncatedPkts              0                  0.0}
\PYG{g+go}{       Ip6InDiscards                   0                  0.0}
\PYG{g+go}{       Ip6InDelivers                   2177604            0.0}
\PYG{g+go}{       Ip6OutForwDatagrams             0                  0.0}
\PYG{g+go}{       Ip6OutRequests                  1567967            0.0}
\PYG{g+go}{       Ip6OutDiscards                  0                  0.0}
\PYG{g+go}{       Ip6OutNoRoutes                  6                  0.0}
\PYG{g+go}{       Ip6ReasmTimeout                 0                  0.0}
\PYG{g+go}{       Ip6ReasmReqds                   0                  0.0}
\PYG{g+go}{       Ip6ReasmOKs                     0                  0.0}
\PYG{g+go}{       Ip6ReasmFails                   0                  0.0}
\PYG{g+go}{       Ip6FragOKs                      0                  0.0}
\PYG{g+go}{       Ip6FragFails                    0                  0.0}
\PYG{g+go}{       Ip6FragCreates                  0                  0.0}
\PYG{g+go}{       Ip6InMcastPkts                  20785              0.0}
\PYG{g+go}{       Ip6OutMcastPkts                 13                 0.0}
\PYG{g+go}{       Ip6InOctets                     2578707266         0.0}
\PYG{g+go}{       Ip6OutOctets                    3533261025         0.0}
\PYG{g+go}{       Ip6InMcastOctets                1442288            0.0}
\PYG{g+go}{       Ip6OutMcastOctets               1252               0.0}
\PYG{g+go}{       Ip6InBcastOctets                0                  0.0}
\PYG{g+go}{       Ip6OutBcastOctets               0                  0.0}
\PYG{g+go}{       Ip6InNoECTPkts                  2060704            0.0}
\PYG{g+go}{       Ip6InECT1Pkts                   0                  0.0}
\PYG{g+go}{       Ip6InECT0Pkts                   137799             0.0}
\PYG{g+go}{       Ip6InCEPkts                     0                  0.0}
\PYG{g+go}{       Icmp6InMsgs                     7525               0.0}
\PYG{g+go}{       Icmp6InErrors                   0                  0.0}
\PYG{g+go}{       Icmp6OutMsgs                    7511               0.0}
\PYG{g+go}{       Icmp6OutErrors                  0                  0.0}
\PYG{g+go}{       Icmp6InCsumErrors               0                  0.0}
\PYG{g+go}{       Icmp6InDestUnreachs             10                 0.0}
\PYG{g+go}{       Icmp6InPktTooBigs               0                  0.0}
\PYG{g+go}{       Icmp6InTimeExcds                0                  0.0}
\PYG{g+go}{       Icmp6InParmProblems             0                  0.0}
\PYG{g+go}{       Icmp6InEchos                    2                  0.0}
\PYG{g+go}{       Icmp6InEchoReplies              6                  0.0}
\PYG{g+go}{       Icmp6InGroupMembQueries         0                  0.0}
\PYG{g+go}{       Icmp6InGroupMembResponses       0                  0.0}
\PYG{g+go}{       Icmp6InGroupMembReductions      0                  0.0}
\PYG{g+go}{       Icmp6InRouterSolicits           0                  0.0}
\PYG{g+go}{       Icmp6InRouterAdvertisements     0                  0.0}
\PYG{g+go}{       Icmp6InNeighborSolicits         4316               0.0}
\PYG{g+go}{       Icmp6InNeighborAdvertisements   3189               0.0}
\PYG{g+go}{       Icmp6InRedirects                0                  0.0}
\PYG{g+go}{       Icmp6InMLDv2Reports             2                  0.0}
\PYG{g+go}{       Icmp6OutDestUnreachs            0                  0.0}
\PYG{g+go}{       Icmp6OutPktTooBigs              0                  0.0}
\PYG{g+go}{       Icmp6OutTimeExcds               0                  0.0}
\PYG{g+go}{       Icmp6OutParmProblems            0                  0.0}
\PYG{g+go}{       Icmp6OutEchos                   6                  0.0}
\PYG{g+go}{       Icmp6OutEchoReplies             2                  0.0}
\PYG{g+go}{       Icmp6OutGroupMembQueries        0                  0.0}
\PYG{g+go}{       Icmp6OutGroupMembResponses      0                  0.0}
\PYG{g+go}{       Icmp6OutGroupMembReductions     0                  0.0}
\PYG{g+go}{       Icmp6OutRouterSolicits          0                  0.0}
\PYG{g+go}{       Icmp6OutRouterAdvertisements    0                  0.0}
\PYG{g+go}{       Icmp6OutNeighborSolicits        3179               0.0}
\PYG{g+go}{       Icmp6OutNeighborAdvertisements  4316               0.0}
\PYG{g+go}{       Icmp6OutRedirects               0                  0.0}
\PYG{g+go}{       Icmp6OutMLDv2Reports            8                  0.0}
\PYG{g+go}{       Icmp6InType1                    10                 0.0}
\PYG{g+go}{       Icmp6InType128                  2                  0.0}
\PYG{g+go}{       Icmp6InType129                  6                  0.0}
\PYG{g+go}{       Icmp6InType135                  4316               0.0}
\PYG{g+go}{       Icmp6InType136                  3189               0.0}
\PYG{g+go}{       Icmp6InType143                  2                  0.0}
\PYG{g+go}{       Icmp6OutType128                 6                  0.0}
\PYG{g+go}{       Icmp6OutType129                 2                  0.0}
\PYG{g+go}{       Icmp6OutType135                 3179               0.0}
\PYG{g+go}{       Icmp6OutType136                 4316               0.0}
\PYG{g+go}{       Icmp6OutType143                 8                  0.0}
\PYG{g+go}{       Udp6InDatagrams                 460                0.0}
\PYG{g+go}{       Udp6NoPorts                     0                  0.0}
\PYG{g+go}{       Udp6InErrors                    0                  0.0}
\PYG{g+go}{       Udp6OutDatagrams                95                 0.0}
\PYG{g+go}{       Udp6RcvbufErrors                0                  0.0}
\PYG{g+go}{       Udp6SndbufErrors                0                  0.0}
\PYG{g+go}{       Udp6InCsumErrors                0                  0.0}
\PYG{g+go}{       Udp6IgnoredMulti                0                  0.0}
\PYG{g+go}{       Udp6MemErrors                   0                  0.0}
\PYG{g+go}{       UdpLite6InDatagrams             0                  0.0}
\PYG{g+go}{       UdpLite6NoPorts                 0                  0.0}
\PYG{g+go}{       UdpLite6InErrors                0                  0.0}
\PYG{g+go}{       UdpLite6OutDatagrams            0                  0.0}
\PYG{g+go}{       UdpLite6RcvbufErrors            0                  0.0}
\PYG{g+go}{       UdpLite6SndbufErrors            0                  0.0}
\PYG{g+go}{       UdpLite6InCsumErrors            0                  0.0}
\PYG{g+go}{       UdpLite6MemErrors               0                  0.0}
\PYG{g+go}{       TcpExtSyncookiesSent            0                  0.0}
\PYG{g+go}{       TcpExtSyncookiesRecv            0                  0.0}
\PYG{g+go}{       TcpExtSyncookiesFailed          0                  0.0}
\PYG{g+go}{       TcpExtEmbryonicRsts             0                  0.0}
\PYG{g+go}{       TcpExtPruneCalled               3791               0.0}
\PYG{g+go}{       TcpExtRcvPruned                 0                  0.0}
\PYG{g+go}{       TcpExtOfoPruned                 0                  0.0}
\PYG{g+go}{       TcpExtOutOfWindowIcmps          0                  0.0}
\PYG{g+go}{       TcpExtLockDroppedIcmps          0                  0.0}
\PYG{g+go}{       TcpExtArpFilter                 0                  0.0}
\PYG{g+go}{       TcpExtTW                        2283               0.0}
\PYG{g+go}{       TcpExtTWRecycled                0                  0.0}
\PYG{g+go}{       TcpExtTWKilled                  0                  0.0}
\PYG{g+go}{       TcpExtPAWSActive                0                  0.0}
\PYG{g+go}{       TcpExtPAWSEstab                 11                 0.0}
\PYG{g+go}{       TcpExtDelayedACKs               31995              0.0}
\PYG{g+go}{       TcpExtDelayedACKLocked          47                 0.0}
\PYG{g+go}{       TcpExtDelayedACKLost            282                0.0}
\PYG{g+go}{       TcpExtListenOverflows           0                  0.0}
\PYG{g+go}{       TcpExtListenDrops               0                  0.0}
\PYG{g+go}{       TcpExtTCPHPHits                 699069             0.0}
\PYG{g+go}{       TcpExtTCPPureAcks               997468             0.0}
\PYG{g+go}{       TcpExtTCPHPAcks                 1235546            0.0}
\PYG{g+go}{       TcpExtTCPRenoRecovery           0                  0.0}
\PYG{g+go}{       TcpExtTCPSackRecovery           2526               0.0}
\PYG{g+go}{       TcpExtTCPSACKReneging           0                  0.0}
\PYG{g+go}{       TcpExtTCPSACKReorder            36858              0.0}
\PYG{g+go}{       TcpExtTCPRenoReorder            0                  0.0}
\PYG{g+go}{       TcpExtTCPTSReorder              85                 0.0}
\PYG{g+go}{       TcpExtTCPFullUndo               1                  0.0}
\PYG{g+go}{       TcpExtTCPPartialUndo            67                 0.0}
\PYG{g+go}{       TcpExtTCPDSACKUndo              11                 0.0}
\PYG{g+go}{       TcpExtTCPLossUndo               0                  0.0}
\PYG{g+go}{       TcpExtTCPLostRetransmit         184                0.0}
\PYG{g+go}{       TcpExtTCPRenoFailures           0                  0.0}
\PYG{g+go}{       TcpExtTCPSackFailures           0                  0.0}
\PYG{g+go}{       TcpExtTCPLossFailures           0                  0.0}
\PYG{g+go}{       TcpExtTCPFastRetrans            7084               0.0}
\PYG{g+go}{       TcpExtTCPSlowStartRetrans       0                  0.0}
\PYG{g+go}{       TcpExtTCPTimeouts               168                0.0}
\PYG{g+go}{       TcpExtTCPLossProbes             345                0.0}
\PYG{g+go}{       TcpExtTCPLossProbeRecovery      82                 0.0}
\PYG{g+go}{       TcpExtTCPRenoRecoveryFail       0                  0.0}
\PYG{g+go}{       TcpExtTCPSackRecoveryFail       0                  0.0}
\PYG{g+go}{       TcpExtTCPRcvCollapsed           0                  0.0}
\PYG{g+go}{       TcpExtTCPBacklogCoalesce        10938              0.0}
\PYG{g+go}{       TcpExtTCPDSACKOldSent           300                0.0}
\PYG{g+go}{       TcpExtTCPDSACKOfoSent           49                 0.0}
\PYG{g+go}{       TcpExtTCPDSACKRecv              317                0.0}
\PYG{g+go}{       TcpExtTCPDSACKOfoRecv           2                  0.0}
\PYG{g+go}{       TcpExtTCPAbortOnData            25                 0.0}
\PYG{g+go}{       TcpExtTCPAbortOnClose           54                 0.0}
\PYG{g+go}{       TcpExtTCPAbortOnMemory          0                  0.0}
\PYG{g+go}{       TcpExtTCPAbortOnTimeout         4                  0.0}
\PYG{g+go}{       TcpExtTCPAbortOnLinger          0                  0.0}
\PYG{g+go}{       TcpExtTCPAbortFailed            0                  0.0}
\PYG{g+go}{       TcpExtTCPMemoryPressures        0                  0.0}
\PYG{g+go}{       TcpExtTCPMemoryPressuresChrono  0                  0.0}
\PYG{g+go}{       TcpExtTCPSACKDiscard            0                  0.0}
\PYG{g+go}{       TcpExtTCPDSACKIgnoredOld        2                  0.0}
\PYG{g+go}{       TcpExtTCPDSACKIgnoredNoUndo     272                0.0}
\PYG{g+go}{       TcpExtTCPSpuriousRTOs           0                  0.0}
\PYG{g+go}{       TcpExtTCPMD5NotFound            0                  0.0}
\PYG{g+go}{       TcpExtTCPMD5Unexpected          0                  0.0}
\PYG{g+go}{       TcpExtTCPMD5Failure             0                  0.0}
\PYG{g+go}{       TcpExtTCPSackShifted            34290              0.0}
\PYG{g+go}{       TcpExtTCPSackMerged             11301              0.0}
\PYG{g+go}{       TcpExtTCPSackShiftFallback      40480              0.0}
\PYG{g+go}{       TcpExtTCPBacklogDrop            0                  0.0}
\PYG{g+go}{       TcpExtPFMemallocDrop            0                  0.0}
\PYG{g+go}{       TcpExtTCPMinTTLDrop             0                  0.0}
\PYG{g+go}{       TcpExtTCPDeferAcceptDrop        0                  0.0}
\PYG{g+go}{       TcpExtIPReversePathFilter       0                  0.0}
\PYG{g+go}{       TcpExtTCPTimeWaitOverflow       0                  0.0}
\PYG{g+go}{       TcpExtTCPReqQFullDoCookies      0                  0.0}
\PYG{g+go}{       TcpExtTCPReqQFullDrop           0                  0.0}
\PYG{g+go}{       TcpExtTCPRetransFail            0                  0.0}
\PYG{g+go}{       TcpExtTCPRcvCoalesce            100585             0.0}
\PYG{g+go}{       TcpExtTCPOFOQueue               15954              0.0}
\PYG{g+go}{       TcpExtTCPOFODrop                0                  0.0}
\PYG{g+go}{       TcpExtTCPOFOMerge               38                 0.0}
\PYG{g+go}{       TcpExtTCPChallengeACK           0                  0.0}
\PYG{g+go}{       TcpExtTCPSYNChallenge           0                  0.0}
\PYG{g+go}{       TcpExtTCPFastOpenActive         0                  0.0}
\PYG{g+go}{       TcpExtTCPFastOpenActiveFail     0                  0.0}
\PYG{g+go}{       TcpExtTCPFastOpenPassive        0                  0.0}
\PYG{g+go}{       TcpExtTCPFastOpenPassiveFail    0                  0.0}
\PYG{g+go}{       TcpExtTCPFastOpenListenOverflow 0                  0.0}
\PYG{g+go}{       TcpExtTCPFastOpenCookieReqd     0                  0.0}
\PYG{g+go}{       TcpExtTCPFastOpenBlackhole      0                  0.0}
\PYG{g+go}{       TcpExtTCPSpuriousRtxHostQueues  0                  0.0}
\PYG{g+go}{       TcpExtBusyPollRxPackets         0                  0.0}
\PYG{g+go}{       TcpExtTCPAutoCorking            73847              0.0}
\PYG{g+go}{       TcpExtTCPFromZeroWindowAdv      40                 0.0}
\PYG{g+go}{       TcpExtTCPToZeroWindowAdv        40                 0.0}
\PYG{g+go}{       TcpExtTCPWantZeroWindowAdv      2870               0.0}
\PYG{g+go}{       TcpExtTCPSynRetrans             91                 0.0}
\PYG{g+go}{       TcpExtTCPOrigDataSent           5948573            0.0}
\PYG{g+go}{       TcpExtTCPHystartTrainDetect     34                 0.0}
\PYG{g+go}{       TcpExtTCPHystartTrainCwnd       1880               0.0}
\PYG{g+go}{       TcpExtTCPHystartDelayDetect     3                  0.0}
\PYG{g+go}{       TcpExtTCPHystartDelayCwnd       261                0.0}
\PYG{g+go}{       TcpExtTCPACKSkippedSynRecv      0                  0.0}
\PYG{g+go}{       TcpExtTCPACKSkippedPAWS         9                  0.0}
\PYG{g+go}{       TcpExtTCPACKSkippedSeq          11                 0.0}
\PYG{g+go}{       TcpExtTCPACKSkippedFinWait2     0                  0.0}
\PYG{g+go}{       TcpExtTCPACKSkippedTimeWait     0                  0.0}
\PYG{g+go}{       TcpExtTCPACKSkippedChallenge    0                  0.0}
\PYG{g+go}{       TcpExtTCPWinProbe               0                  0.0}
\PYG{g+go}{       TcpExtTCPKeepAlive              67                 0.0}
\PYG{g+go}{       TcpExtTCPMTUPFail               0                  0.0}
\PYG{g+go}{       TcpExtTCPMTUPSuccess            0                  0.0}
\PYG{g+go}{       TcpExtTCPDelivered              5951000            0.0}
\PYG{g+go}{       TcpExtTCPDeliveredCE            0                  0.0}
\PYG{g+go}{       TcpExtTCPAckCompressed          3021               0.0}
\PYG{g+go}{       TcpExtTCPZeroWindowDrop         0                  0.0}
\PYG{g+go}{       TcpExtTCPRcvQDrop               0                  0.0}
\PYG{g+go}{       TcpExtTCPWqueueTooBig           0                  0.0}
\PYG{g+go}{       TcpExtTCPFastOpenPassiveAltKey  0                  0.0}
\PYG{g+go}{       TcpExtTcpTimeoutRehash          72                 0.0}
\PYG{g+go}{       TcpExtTcpDuplicateDataRehash    0                  0.0}
\PYG{g+go}{       TcpExtTCPDSACKRecvSegs          371                0.0}
\PYG{g+go}{       TcpExtTCPDSACKIgnoredDubious    0                  0.0}
\PYG{g+go}{       TcpExtTCPMigrateReqSuccess      0                  0.0}
\PYG{g+go}{       TcpExtTCPMigrateReqFailure      0                  0.0}
\PYG{g+go}{       IpExtInNoRoutes                 0                  0.0}
\PYG{g+go}{       IpExtInTruncatedPkts            0                  0.0}
\PYG{g+go}{       IpExtInMcastPkts                62                 0.0}
\PYG{g+go}{       IpExtOutMcastPkts               24                 0.0}
\PYG{g+go}{       IpExtInBcastPkts                19989              0.0}
\PYG{g+go}{       IpExtOutBcastPkts               0                  0.0}
\PYG{g+go}{       IpExtInOctets                   533061309          0.0}
\PYG{g+go}{       IpExtOutOctets                  5153892360         0.0}
\PYG{g+go}{       IpExtInMcastOctets              7448               0.0}
\PYG{g+go}{       IpExtOutMcastOctets             3592               0.0}
\PYG{g+go}{       IpExtInBcastOctets              2082276            0.0}
\PYG{g+go}{       IpExtOutBcastOctets             0                  0.0}
\PYG{g+go}{       IpExtInCsumErrors               0                  0.0}
\PYG{g+go}{       IpExtInNoECTPkts                1073527            0.0}
\PYG{g+go}{       IpExtInECT1Pkts                 0                  0.0}
\PYG{g+go}{       IpExtInECT0Pkts                 0                  0.0}
\PYG{g+go}{       IpExtInCEPkts                   0                  0.0}
\PYG{g+go}{       IpExtReasmOverlaps              0                  0.0}
\PYG{g+go}{       MPTcpExtMPCapableSYNRX          0                  0.0}
\PYG{g+go}{       MPTcpExtMPCapableSYNTX          2203               0.0}
\PYG{g+go}{       MPTcpExtMPCapableSYNACKRX       2172               0.0}
\PYG{g+go}{       MPTcpExtMPCapableACKRX          0                  0.0}
\PYG{g+go}{       MPTcpExtMPCapableFallbackACK    0                  0.0}
\PYG{g+go}{       MPTcpExtMPCapableFallbackSYNACK 22                 0.0}
\PYG{g+go}{       MPTcpExtMPFallbackTokenInit     0                  0.0}
\PYG{g+go}{       MPTcpExtMPTCPRetrans            0                  0.0}
\PYG{g+go}{       MPTcpExtMPJoinNoTokenFound      0                  0.0}
\PYG{g+go}{       MPTcpExtMPJoinSynRx             0                  0.0}
\PYG{g+go}{       MPTcpExtMPJoinSynAckRx          0                  0.0}
\PYG{g+go}{       MPTcpExtMPJoinSynAckHMacFailure 0                  0.0}
\PYG{g+go}{       MPTcpExtMPJoinAckRx             0                  0.0}
\PYG{g+go}{       MPTcpExtMPJoinAckHMacFailure    0                  0.0}
\PYG{g+go}{       MPTcpExtDSSNotMatching          0                  0.0}
\PYG{g+go}{       MPTcpExtInfiniteMapRx           0                  0.0}
\PYG{g+go}{       MPTcpExtDSSNoMatchTCP           0                  0.0}
\PYG{g+go}{       MPTcpExtDataCsumErr             0                  0.0}
\PYG{g+go}{       MPTcpExtOFOQueueTail            0                  0.0}
\PYG{g+go}{       MPTcpExtOFOQueue                0                  0.0}
\PYG{g+go}{       MPTcpExtOFOMerge                0                  0.0}
\PYG{g+go}{       MPTcpExtNoDSSInWindow           0                  0.0}
\PYG{g+go}{       MPTcpExtDuplicateData           0                  0.0}
\PYG{g+go}{       MPTcpExtAddAddr                 0                  0.0}
\PYG{g+go}{       MPTcpExtEchoAdd                 0                  0.0}
\PYG{g+go}{       MPTcpExtPortAdd                 0                  0.0}
\PYG{g+go}{       MPTcpExtAddAddrDrop             0                  0.0}
\PYG{g+go}{       MPTcpExtMPJoinPortSynRx         0                  0.0}
\PYG{g+go}{       MPTcpExtMPJoinPortSynAckRx      0                  0.0}
\PYG{g+go}{       MPTcpExtMPJoinPortAckRx         0                  0.0}
\PYG{g+go}{       MPTcpExtMismatchPortSynRx       0                  0.0}
\PYG{g+go}{       MPTcpExtMismatchPortAckRx       0                  0.0}
\PYG{g+go}{       MPTcpExtRmAddr                  0                  0.0}
\PYG{g+go}{       MPTcpExtRmAddrDrop              0                  0.0}
\PYG{g+go}{       MPTcpExtRmSubflow               0                  0.0}
\PYG{g+go}{       MPTcpExtMPPrioTx                0                  0.0}
\PYG{g+go}{       MPTcpExtMPPrioRx                0                  0.0}
\PYG{g+go}{       MPTcpExtMPFailTx                0                  0.0}
\PYG{g+go}{       MPTcpExtMPFailRx                0                  0.0}
\PYG{g+go}{       MPTcpExtMPFastcloseTx           0                  0.0}
\PYG{g+go}{       MPTcpExtMPFastcloseRx           0                  0.0}
\PYG{g+go}{       MPTcpExtMPRstTx                 17                 0.0}
\PYG{g+go}{       MPTcpExtMPRstRx                 0                  0.0}
\PYG{g+go}{       MPTcpExtRcvPruned               0                  0.0}
\PYG{g+go}{       MPTcpExtSubflowStale            0                  0.0}
\PYG{g+go}{       MPTcpExtSubflowRecover          0                  0.0}
\end{sphinxVerbatim}

\sphinxAtStartPar
Among all these variables, the ones named \sphinxcode{\sphinxupquote{\textbackslash{}*Ext\textbackslash{}*}} are Linux specific
variables that are not defined in IETF MIBs. The others are usually defined
in an IETF RFC. The counters maintained by the Linux kernel are defined in
\sphinxhref{https://github.com/torvalds/linux/blob/master/include/uapi/linux/snmp.h}{include/uapi/linux/snmp.h} and
\sphinxhref{https://github.com/torvalds/linux/blob/master/net/mptcp/mib.h}{net/mptcp/mib.h} for the Multipath TCP counters.
Each of the counters exposed by \sphinxhref{https://www.man7.org/linux/man-pages/man8/nstat.8.html}{nstat} correspond to one specific identifier
in the Linux kernel. For example, the beginning of the IP part of the
counters is defined as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum}
\PYG{p}{\PYGZob{}}
\PYG{+w}{     }\PYG{n}{IPSTATS\PYGZus{}MIB\PYGZus{}NUM}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{+w}{     }\PYG{c+cm}{/* frequently written fields in fast path, kept in same cache line */}
\PYG{+w}{     }\PYG{n}{IPSTATS\PYGZus{}MIB\PYGZus{}INPKTS}\PYG{p}{,}\PYG{+w}{                     }\PYG{c+cm}{/* InReceives */}
\PYG{+w}{     }\PYG{n}{IPSTATS\PYGZus{}MIB\PYGZus{}INOCTETS}\PYG{p}{,}\PYG{+w}{                   }\PYG{c+cm}{/* InOctets */}
\PYG{+w}{     }\PYG{n}{IPSTATS\PYGZus{}MIB\PYGZus{}INDELIVERS}\PYG{p}{,}\PYG{+w}{                 }\PYG{c+cm}{/* InDelivers */}
\PYG{+w}{     }\PYG{n}{IPSTATS\PYGZus{}MIB\PYGZus{}OUTFORWDATAGRAMS}\PYG{p}{,}\PYG{+w}{           }\PYG{c+cm}{/* OutForwDatagrams */}
\PYG{+w}{     }\PYG{n}{IPSTATS\PYGZus{}MIB\PYGZus{}OUTPKTS}\PYG{p}{,}\PYG{+w}{                    }\PYG{c+cm}{/* OutRequests */}
\PYG{+w}{     }\PYG{n}{IPSTATS\PYGZus{}MIB\PYGZus{}OUTOCTETS}\PYG{p}{,}\PYG{+w}{                  }\PYG{c+cm}{/* OutOctets */}
\PYG{+w}{     }\PYG{c+cm}{/* other fields */}
\end{sphinxVerbatim}

\sphinxAtStartPar
Before looking at the precise meaning of each of the counters managed by
\sphinxhref{https://www.man7.org/linux/man-pages/man8/nstat.8.html}{nstat},
it is interesting to recall the definition of the Case diagrams. This graphical
representation of SNMP variables can be really useful to understand the
meaning of the Linux networking counters.


\section{The Case diagrams}
\label{\detokenize{nstat-intro:the-case-diagrams}}
\sphinxAtStartPar
The \index{Case diagrams@\spxentry{Case diagrams}}Case diagrams were introduced by Jeffrey Case and Craig
Partridge in 1989 in the paper \sphinxhref{https://doi.org/10.1145/66093.66094}{Case diagrams: a first step to diagrammed
management information bases}.
This article describes a simple but powerful graphical representation
of the interactions among the different SNMP variables that a networking
stack maintains.

\sphinxAtStartPar
A \sphinxtitleref{Case diagram} represents the flow of packets through a stack and the
different variables that are updated as the packet progress through the
stack. The incoming packets are represented as progressing from
the bottom layer of the stack to the upper layer, while the outgoing
packets are represented in the other direction. The progression of these
packets is represented using a large arrow. An horizontal line
that crosses this arrow indicates the point in the stack where the associated
SNMP counter is updated. A small that leaves the main packet processing
flow indicates a specific treatment for a packet and a counter
that is updated. In some cases, an arrow enters the main workflow and
updates the associated counter.

\sphinxAtStartPar
The original paper used the IP counters of the MIB\sphinxhyphen{}2 to illustrate the
\sphinxtitleref{Case diagrams}. This figure is reproduced below in ASCII format to simplify
the updates to the document.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{                   Transport Layer}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{                         /\PYGZbs{}}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{ IpInDelivers +++++++++++++++}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} IpInUnknownProtos}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{ IpInDiscards \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+|}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  IpReasmOKs}
\PYG{g+go}{                         ||                     /\PYGZbs{}}
\PYG{g+go}{                         ||   IpReasmFails  \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+|}
\PYG{g+go}{                         ||                     ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} IpReasmReqds}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{ IpForwDatagrams \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+|}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} IpInAddrErrors}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{ IpInHdrErrors \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+|}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{                      +++++++++++++++++++ IpInReceives}
\PYG{g+go}{                         ||}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{                   Interface Layer}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxtitleref{Case diagram} above shows how the packets are processed by the
IP stack. First, the Interface layer extracts the payload of the
received frame and passes it to the IP layer. At this point, the
\sphinxcode{\sphinxupquote{IpInReceives}} counter is incremented. The processing of the
IPv4 packet starts. First, the stack checks for errors inside the IPv4
header. If an error is detected in the IPv4 header, the packet is dropped
and \sphinxcode{\sphinxupquote{IpInHdrErrors}} is incremented. Then, the destination address is checked.
If the address is incorrect, the packet processing stops and \sphinxcode{\sphinxupquote{IpInAddrErrors}}
is incremented.

\sphinxAtStartPar
If IP forwarding is enabled and the packet is not destined to this host,
then the packet is forwarded using the FIB. The \sphinxcode{\sphinxupquote{IpForwDatagrams}} counter
is incremented.

\sphinxAtStartPar
The next step is to check whether the received packet is a fragment of
a larger packet that needs to be reassembled. If the received packet is a
fragment, then the \sphinxcode{\sphinxupquote{IpReasmReqds}} counter is incremented and the
packet passed through the reassembly process. This reassembly can take time
since more fragments can be required to recover a complete packet. If
the packet reassembly succeeds, then \sphinxcode{\sphinxupquote{IpReasmOKs}} is incremented and
the processing of the full packet continues. If the reassembly fails, e.g.
because a fragment is missing before the timeout expires, then
\sphinxcode{\sphinxupquote{IpReamsFails}} gets incremented.

\sphinxAtStartPar
A this point, the packets have almost finished to be processed by the
IP stack. Most packets will be delivered to the transport layer
and increment the \sphinxcode{\sphinxupquote{IpInDelivers}} counter except if the IP queue becomes
full. In this case, the \sphinxcode{\sphinxupquote{IpInDiscards}} counter is incremented.
The incoming packet could also be discarded if its \sphinxtitleref{Protocol} field
does not match one of the transport layers supported by the stack
(i.e. UDP, TCP, DCCP, …). In this case, the \sphinxcode{\sphinxupquote{IpInUnknownProtos}}
counter is incremented.


\chapter{The Multipath TCP counters}
\label{\detokenize{nstat-mptcp:the-multipath-tcp-counters}}\label{\detokenize{nstat-mptcp::doc}}
\sphinxAtStartPar
Linux version 5.18 maintains 46 counters for Multipath TCP. These counters
correspond to different parts of the protocol and can be organized in four
groups. The first group gathers the counters that are incremented when TCP
packets containing the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option are processed. The second group
gathers the counters that are incremented when processing packets with
the \sphinxcode{\sphinxupquote{MP\_JOIN}} option. The third group gathers the counters that are
modified when packets with the \sphinxcode{\sphinxupquote{ADD\_ADDR}}, \sphinxcode{\sphinxupquote{RM\_ADDR}} or \sphinxcode{\sphinxupquote{MP\_PRIO}} option
are processed. The fourth group gathers the remaining counters of the
Multipath TCP stack.

\sphinxAtStartPar
Two versions of Multipath TCP have been specified within the IETF. Version
0 was initially defined in \index{RFC@\spxentry{RFC}!RFC 6824@\spxentry{RFC 6824}}\sphinxhref{https://tools.ietf.org/html/rfc6824.html}{\sphinxstylestrong{RFC 6824}}. The off\sphinxhyphen{}tree but well
maintained set of patches distributed by
\sphinxurl{https://www.multipath-tcp.org} implemented
this version of Multipath TCP. Based on the experience gathered with this
implementation and also Apple’s implementation, Multipath TCP evolved and
the IETF published version 1 in \index{RFC@\spxentry{RFC}!RFC 8684@\spxentry{RFC 8684}}\sphinxhref{https://tools.ietf.org/html/rfc8684.html}{\sphinxstylestrong{RFC 8684}}. The Multipath TCP counters
correspond to this version of Multipath TCP.


\section{The MPCapable counters}
\label{\detokenize{nstat-mptcp:the-mpcapable-counters}}
\sphinxAtStartPar
This group gathers the following counters: \sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNRX}},
\sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNTX}}, \sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNACKRX}},
\sphinxcode{\sphinxupquote{MPTcpExtMPCapableACKRX}}, \sphinxcode{\sphinxupquote{MPTcpExtMPCapableFallbackACK}},
\sphinxcode{\sphinxupquote{MPTcpExtMPCapableFallbackSYNACK}} and \sphinxcode{\sphinxupquote{MPTcpExtMPFallbackTokenInit}}. They
relate to the establishment of the initial Multipath TCP subflow
which is described in the {\hyperref[\detokenize{mptcp:mptcp-initial-mptcp-handshake}]{\sphinxcrossref{\DUrole{std,std-ref}{The Multipath TCP handshake}}}} section.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNTX}} counter is similar to the \sphinxcode{\sphinxupquote{TcpActiveOpens}}
counter maintained by TCP. It counts the number of Multipath TCP connections
that this host has tried to establish. Its value will usually be much smaller than \sphinxcode{\sphinxupquote{TcpActiveOpens}}. When a Multipath connection is initiated using the
\sphinxcode{\sphinxupquote{connect}} system call, both \sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNTX}} and
\sphinxcode{\sphinxupquote{TcpActiveOpens}} are incremented. Although the name of the counter is
\sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNTX}}, it is only incremented once per Multipath
TCP connection if the \sphinxcode{\sphinxupquote{SYN}} packet needs to be retransmitted.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNACKRX}} counter is incremented every time
a Multipath TCP connection is confirmed by the reception of a
\sphinxcode{\sphinxupquote{SYN+ACK}} with the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option to a \sphinxcode{\sphinxupquote{SYN}} packet
that it sent earlier. The value of this counter should be lower than
\sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNTX}} since only a subset of the connections initiated
by a host will typically reach a Multipath TCP compliant server.
If a client receives a \sphinxcode{\sphinxupquote{SYN+ACK}} without the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option
in response to a \sphinxcode{\sphinxupquote{SYN}} sent with the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option, then
the \sphinxcode{\sphinxupquote{MPTcpExtMPCapableFallbackSYNACK}} counter is incremented. This
counter tracks the Multipath TCP connections that were forced to fall back
to regular TCP during the three\sphinxhyphen{}way handshake of the initial subflow.

\sphinxAtStartPar
On the other hand, the \sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNRX}} counter tracks the
number of Multipath TCP connections that were accepted by the host.
Its value will usually be much smaller than \sphinxcode{\sphinxupquote{TcpPassiveOpens}} which
tracks all accepted TCP connections. When a Multipath connection is accepted,
both \sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNRX}} and \sphinxcode{\sphinxupquote{TcpPassiveOpens}} are incremented.
As for \sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNTX}}, the \sphinxcode{\sphinxupquote{MPTcpExtMPCapableSYNRX}} counter is
only incremented once per connection and not each time a packet is received.
Upon reception of a \sphinxcode{\sphinxupquote{SYN}} with the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option, a
Multipath TCP server returns a \sphinxcode{\sphinxupquote{SYN+ACK}} with the \sphinxcode{\sphinxupquote{MP\_CAPABLE}}
option. The \sphinxcode{\sphinxupquote{MPTcpExtMPCapableACKRX}} counter is incremented upon reception
of the third \sphinxcode{\sphinxupquote{ACK}} containing the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option. If this option
is not present in this \sphinxcode{\sphinxupquote{ACK}}, then the \sphinxcode{\sphinxupquote{MPTcpExtMPCapableFallbackACK}}
gets incremented.
If this counter increases, it probably indicates some interference with a
middlebox that injects acknowledgments during the three\sphinxhyphen{}way handshake.

\begin{sphinxadmonition}{note}{\label{\detokenize{nstat-mptcp:id1}}Todo:}
\sphinxAtStartPar
find example ?
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{\label{\detokenize{nstat-mptcp:id2}}Todo:}
\sphinxAtStartPar
MPTcpExtMPFallbackTokenInit  seems related to the failure of getting a token during the handshake (e.g. because there are too many tokens already or not enough randomness), but there are cases in subflow joins where this counter is also incremented
\end{sphinxadmonition}
\sphinxSetupCaptionForVerbatim{The MPCapable counters (active opens)}
\def\sphinxLiteralBlockLabel{\label{\detokenize{nstat-mptcp:id6}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{ MPTcpExtMPCapableSYNTX+++++++++++++++}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MPTcpExtMPCapableSYNACKRX}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MPTcpExtMPCapableFallbackSYNACK}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\end{sphinxVerbatim}
\sphinxSetupCaptionForVerbatim{The MPCapable counters (passive opens)}
\def\sphinxLiteralBlockLabel{\label{\detokenize{nstat-mptcp:id7}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{ MPTcpExtMPCapableSYNRX+++++++++++++++}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MPTcpExtMPCapableACKRX}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MPTcpExtMPCapableFallbackACK}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\end{sphinxVerbatim}


\section{The Join counters}
\label{\detokenize{nstat-mptcp:the-join-counters}}
\sphinxAtStartPar
There are thirteen counters in this group. They are incremented when a host
processes \sphinxcode{\sphinxupquote{SYN}} packets corresponding to additional subflows.

\sphinxAtStartPar
The first counter, \sphinxcode{\sphinxupquote{MPTcpExtMPJoinSynRx}} is incremented every time a
\sphinxcode{\sphinxupquote{SYN}} packet with the \sphinxcode{\sphinxupquote{MP\_JOIN}} option is received. Upon reception
of a such packet, the host first verifies that it knows the token of
the Multipath TCP connection. If so, the processing continues and
the host returns a \sphinxcode{\sphinxupquote{SYN+ACK}} packet with the \sphinxcode{\sphinxupquote{MP\_JOIN}} option, its
random number and a HMAC. Otherwise, the \sphinxcode{\sphinxupquote{MPTcpExtMPJoinNoTokenFound}}
counter is incremented. The host then waits for the third \sphinxcode{\sphinxupquote{ACK}}
which contains the \sphinxcode{\sphinxupquote{MP\_JOIN}} option and the HMAC computed by
the remote host. It then checks the validity of the received HMAC. If
the HMAC is invalid, then the \sphinxcode{\sphinxupquote{MPTcpExtMPJoinAckHMacFailure}} counter
is incremented.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{MPTcpExtMPJoinSynRx}} counter will increase on Multipath TCP hosts
that accept subflows, typically servers. The value of the
\sphinxcode{\sphinxupquote{MPTcpExtMPJoinACKRX}} counter should be close to the previous one.
If the two other counters, \sphinxcode{\sphinxupquote{MPTcpExtMPJoinNoTokenFound}} or
\sphinxcode{\sphinxupquote{MPTcpExtMPJoinAckHMacFailure}} increase, then the system administrator
should probably investigate as these are indication of possible attacks.
\sphinxSetupCaptionForVerbatim{The Join counters when accepting subflows}
\def\sphinxLiteralBlockLabel{\label{\detokenize{nstat-mptcp:id8}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{ MPTcpExtMPJoinSynRX +++++++++++++++}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MPTcpExtMPJoinNoTokenFound}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{ MPTcpExtMPJoinACKRX +++++++++++++++}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MPTcpExtMPJoinAckHMacFailure}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\end{sphinxVerbatim}

\sphinxAtStartPar
Unfortunately, there is no counter that tracks the creation of new subflows
by a host. The TCP stack counts these new subflows as active opens, but
there is no specific Multipath TCP counter. However, the
\sphinxcode{\sphinxupquote{MPTcpExtMPJoinSynAckRX}} counter tracks the reception of \sphinxcode{\sphinxupquote{SYN+ACK}}
packets containing the \sphinxcode{\sphinxupquote{MP\_JOIN}} option. This is thus an indirect
way to track the creation of new subflows. Upon reception of such a
packet, in response to a previously sent \sphinxcode{\sphinxupquote{SYN}} packet with the \sphinxcode{\sphinxupquote{MP\_JOIN}}
option, a host checks the validity of the received HMAC. If the HMAC is
invalid, the \sphinxcode{\sphinxupquote{MPTcpExtMPJoinSynAckHMacFailure}} is incremented. This counter
should rarely increase. If it increases, then the problem should be
investigated by collecting packet traces.
\sphinxSetupCaptionForVerbatim{The Join counters when initiating subflows}
\def\sphinxLiteralBlockLabel{\label{\detokenize{nstat-mptcp:id9}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{ MPTcpExtMPJoinSynAckRX +++++++++++++++}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         |+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MPTcpExtMPJoinSynAckHMacFailure}
\PYG{g+go}{                         ||}
\PYG{g+go}{                         ||}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{\label{\detokenize{nstat-mptcp:id3}}Todo:}
\sphinxAtStartPar
This part is unclear and needs to be checked based on the tests
\end{sphinxadmonition}

\sphinxAtStartPar
A Multipath TCP host will usually accept additional subflows on the address
and ports where the initial subflow was accepted. The following counters
track the arrival of packets destined to different port numbers:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MPTcpExtMPJoinPortSynRx}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MPTcpExtMPJoinPortSynAckRx}}
\sphinxcode{\sphinxupquote{MPTcpExtMPJoinPortAckRx}}

\end{itemize}

\sphinxAtStartPar
The last two counters, \sphinxcode{\sphinxupquote{MPTcpExtMismatchPortSynRx}} and
\sphinxcode{\sphinxupquote{MPTcpExtMismatchPortAckRx}} are a bit different. They are incremented when
a \sphinxcode{\sphinxupquote{SYN}} or \sphinxcode{\sphinxupquote{ACK}} sent to a different port number are received.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{MP\_JOIN}} option contains a \sphinxcode{\sphinxupquote{B}} that indicates whether the new
subflow should be considered as a backup subflow or a regular one. This
information is used by the path manager, but no counter tracks the value of
the backup bit in the \sphinxcode{\sphinxupquote{MP\_JOIN}} option. Once a subflow has been established,
its backup status can be changed using the \sphinxcode{\sphinxupquote{MP\_PRIO}} option. The
\sphinxcode{\sphinxupquote{MPTcpExtMPPrioTx}} counter is incremented every time such an option is sent.
The \sphinxcode{\sphinxupquote{MPTcpExtMPPrioRx}} counter is incremented by each received \sphinxcode{\sphinxupquote{MP\_PRIO}}
option.


\section{The address advertisement counters}
\label{\detokenize{nstat-mptcp:the-address-advertisement-counters}}
\sphinxAtStartPar
There are six counters in this group. The advertisement of addresses by
Multipath TCP is described in ref:\sphinxtitleref{Address management \textless{}mmtpbook:mptcp\sphinxhyphen{}addr\sphinxhyphen{}management\textgreater{}}.

\sphinxAtStartPar
When a host receives a packet with a valid \sphinxcode{\sphinxupquote{ADD\_ADDR}} option with its
\sphinxcode{\sphinxupquote{Echo}} bit set to zero, the \sphinxcode{\sphinxupquote{MPTcpExtAddAddr}} counter is incremented.
If this option includes an optional port number, the \sphinxcode{\sphinxupquote{MPTcpExtPortAdd}}
counter is also incremented. In addition to these two counters, the
\sphinxcode{\sphinxupquote{MPTcpExtAddAddrDrop}} tracks the address advertisements that were received
by the host, but not processed by the path manager, e.g. because no user
space path manager was active.

\sphinxAtStartPar
Multipath TCP does not track the advertisements of addresses by sending
the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option. However, it tracks the reception of packets
containing the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option with the \sphinxcode{\sphinxupquote{Echo}} bit set to one with
the \sphinxcode{\sphinxupquote{MPTcpExtEchoAdd}} counter. These packets are echoed by the remote host.

\sphinxAtStartPar
Similarly, the \sphinxcode{\sphinxupquote{MPTcpExtRmAddr}} counter tracks the number of received
\sphinxcode{\sphinxupquote{RM\_ADDR}} options. These options typically indicate a change in the
addresses owned by a remote peer. Mobile hosts are likely to send these
options when they move from one type of network to another. The
\sphinxcode{\sphinxupquote{MPTcpExtRmAddrDrop}} is incremented when the path manager cannot process an
incoming \sphinxcode{\sphinxupquote{RM\_ADDR}} option.

\begin{sphinxadmonition}{note}{\label{\detokenize{nstat-mptcp:id4}}Todo:}
\sphinxAtStartPar
is this a rare event ?
\end{sphinxadmonition}

\sphinxAtStartPar
When a host receives a \sphinxcode{\sphinxupquote{RM\_ADDR}} option from a remote peer, its path
manager should remove the subflows associated with this address. The
\sphinxcode{\sphinxupquote{MPTcpExtRmSubflow}} counter tracks the number of subflows that have
been destroyed by a path manager.


\section{The connection termination counters}
\label{\detokenize{nstat-mptcp:the-connection-termination-counters}}
\sphinxAtStartPar
There are seven counters in this group. They track the abnormal termination of
a Multipath TCP connection. A normal Multipath TCP connection should end
with the exchange of \sphinxcode{\sphinxupquote{DATA\_FIN}} in both directions. However, are scenarios
are possible. First, one of the hosts may wish to quickly terminate the
Multipath TCP connection without having to maintain state. Multipath TCP
uses the \sphinxcode{\sphinxupquote{FAST\_CLOSE}} option
in this case. The \sphinxcode{\sphinxupquote{MPTcpExtMPFastcloseTx}} and \sphinxcode{\sphinxupquote{MPTcpExtMPFastcloseRx}}
counters track the transmission and the reception of such options.

\sphinxAtStartPar
Multipath TCP was designed to prevent as much as possible interference
from middleboxes, but there are some types of interferences that force
Multipath TCP to fallback to regular TCP. In this case, the host that first
noticed the interference (e.g. problem during the handshake, DSS checksum
problem, …) sends a packet with the \sphinxcode{\sphinxupquote{MP\_FAIL}} option. This forces the
Multipath TCP connection to fall back to a regular TCP connection.
The \sphinxcode{\sphinxupquote{MPTcpExtMPFailTx}} and \sphinxcode{\sphinxupquote{MPTcpExtMPFailRx}} counters track the
transmission and the reception of the \sphinxcode{\sphinxupquote{MP\_FAIL}} option. During some
types of fall backs, a host may also send an infinite DSS mapping. The
\sphinxcode{\sphinxupquote{MPTcpExtInfiniteMapRx}} counter tracks the reception of such infinite
DSS mappings.

\sphinxAtStartPar
An increase of
these counters would indicate some type of middlebox interference which
should be investigated since it could prevent a complete utilization of
Multipath TCP.

\sphinxAtStartPar
Like TCP, Multipath TCP uses TCP \sphinxcode{\sphinxupquote{RST}} to terminate subflows. Multipath
TCP also defines the \sphinxcode{\sphinxupquote{MP\_TCPRST}} option which can contain an option reason
code and flags indicating some information about the reason for the
transmission of the \sphinxcode{\sphinxupquote{RST}}. The \sphinxcode{\sphinxupquote{MPTcpExtMPRstTx}} and \sphinxcode{\sphinxupquote{MPTcpExtMPRstRx}}
counters track the transmission and the reception of such \sphinxcode{\sphinxupquote{RST}} packets.


\section{The other counters}
\label{\detokenize{nstat-mptcp:the-other-counters}}
\sphinxAtStartPar
The remaining eleven counters are mainly related to processing of data.

\sphinxAtStartPar
If the DSS checksum is enabled, the \sphinxcode{\sphinxupquote{MPTcpExtDataCsumErr}} is incremented
every time a check of the DSS checksum fails. This should be a rare event that
likely indicates the presence of middleboxes. It should be correlated with
the \sphinxcode{\sphinxupquote{MPTcpExtMPFailTx}} and \sphinxcode{\sphinxupquote{MPTcpExtMPFailRx}} counters discussed in the
previous section.

\sphinxAtStartPar
Three counters track the DSS option of the incoming packets :
\sphinxcode{\sphinxupquote{MPTcpExtDSSNotMatching}}, \sphinxcode{\sphinxupquote{MPTcpExtDSSNoMatchTCP}} and
\sphinxcode{\sphinxupquote{MPTcpExtNoDSSInWindow}}. The first counter is
incremented when a mapping is received for data that has already been mapped
and the new mapping is not the same as the existing one. The second counter
is incremented when the TCP sequence numbers found in the mapping do not
match with the current TCP sequence numbers. The third counter is incremented
upon reception of a packet that indicates a DSS option that is outside the
current window. These three counters should rarely increase.

\sphinxAtStartPar
The last counter that tracks data at the Multipath TCP connection
level is \sphinxcode{\sphinxupquote{MPTcpExtDuplicateData}}. It counts the number of received
packets whose data has been ignored because it had already been received
earlier. Such duplicated data can occur with Multipath TCP when data
sent over a subflow is retransmitted over another subflow. It would
be interesting to follow the evolution of this counter on a server that
interacts with mobile devices.

\begin{sphinxadmonition}{note}{\label{\detokenize{nstat-mptcp:id5}}Todo:}
\sphinxAtStartPar
check with Matthieu
\end{sphinxadmonition}

\sphinxAtStartPar
Multipath TCP tracks losses on the subflows that compose a Multipath
TCP connection. If one subflow accumulates losses, it may be marked
as stale and the packet scheduler will stop using it to transmit data
until the losses have been recovered. The \sphinxcode{\sphinxupquote{MPTcpExtSubflowStale}} counter is
incremented every time a subflow is marked as being stale. The
\sphinxcode{\sphinxupquote{MPTcpExtSubflowRecover}} counter tracks the transitions from stale to
active.

\sphinxAtStartPar
Multipath TCP uses an out\sphinxhyphen{}of\sphinxhyphen{}order queue to reorder the data received over
the different subflows. The \sphinxcode{\sphinxupquote{MPTcpExtOFOQueueTail}} and \sphinxcode{\sphinxupquote{MPTcpExtOFOQueue}}   counters track the insertion of data at the tail and in the out\sphinxhyphen{}of\sphinxhyphen{}order
queue. The \sphinxcode{\sphinxupquote{MPTcpExtOFOMerge}} is incremented when data present in the
out\sphinxhyphen{}or\sphinxhyphen{}order queue can be merged.

\sphinxAtStartPar
Finally, the \sphinxcode{\sphinxupquote{MPTcpExtRcvPruned}} tracks the number of packets that
were dropped because the memory available for Multipath TCP was full.
If this counter increases, you should probably check the memory configuration
of your host.


\chapter{The Transmission Control Protocol (TCP)}
\label{\detokenize{tcp:the-transmission-control-protocol-tcp}}\label{\detokenize{tcp:chapter-tcp}}\label{\detokenize{tcp::doc}}
\sphinxAtStartPar
TCP is a connection\sphinxhyphen{}oriented transport protocol. This means that a TCP connection must be established before communicating hosts can exchange data. A connection is a logical relation between the two communication hosts. Each hosts maintains some state about the connection and uses it to manage the connection.

\sphinxAtStartPar
TCP uses the three\sphinxhyphen{}way handshake as shown in \hyperref[\detokenize{tcp:fig-tcp-handshake}]{Fig.\@ \ref{\detokenize{tcp:fig-tcp-handshake}}}. To initiate a connection, the client sends a TCP segment with the \sphinxcode{\sphinxupquote{SYN}} flag set. Such a segment is usually called a \sphinxcode{\sphinxupquote{SYN}} segment. It contains a random sequence number (\sphinxtitleref{x} in \hyperref[\detokenize{tcp:fig-tcp-handshake}]{Fig.\@ \ref{\detokenize{tcp:fig-tcp-handshake}}}). If the server accepts the connection, it replies with a \sphinxcode{\sphinxupquote{SYN+ACK}} segment whose \sphinxcode{\sphinxupquote{SYN}} and \sphinxcode{\sphinxupquote{ACK}} flags are set. The acknowledgment number of this segment is set to \sphinxcode{\sphinxupquote{x+1}} to confirm the reception of the \sphinxcode{\sphinxupquote{SYN}} segment sent by the client. The server selects a random sequence number (\sphinxtitleref{y} in \hyperref[\detokenize{tcp:fig-tcp-handshake}]{Fig.\@ \ref{\detokenize{tcp:fig-tcp-handshake}}}). Finally, the client replies with an \sphinxtitleref{ACK} segment that acknowledges the reception of the \sphinxcode{\sphinxupquote{SYN+ACK}} segment.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=5; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Client};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, fill=white] {SYN\small{[seq=x]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}};
\draw[blue,thick, ->] (\c1,\y-2) -- (\s1,\y-3) node [midway, fill=white] {ACK\small{[seq=x+1,ack=y+1]}};
\end{tikzpicture}\caption{Establishing a TCP connection using the three\sphinxhyphen{}way handshake}\label{\detokenize{tcp:id5}}\label{\detokenize{tcp:fig-tcp-handshake}}\end{figure}
\sphinxAtStartPar
TCP was designed to be extensible. The TCP header contains a TCP Header Length (THL) field that indicates the total length of the TCP header in four\sphinxhyphen{}bytes words. For the normal header, this field is set to 5, which corresponds to the 20 bytes long TCP header. Larger values of the THL field indicate that the segment contains one or more TCP options. TCP options are encoded as a Type\sphinxhyphen{}Length\sphinxhyphen{}Value field. The first byte specifies the Type, the second byte indicates the length of the entire TCP option in bytes. The utilization of TCP options is usually negotiated during the three\sphinxhyphen{}way\sphinxhyphen{}exchange. The client adds a TCP option in the \sphinxcode{\sphinxupquote{SYN}} segment. If the server does not recognize the option, it simply ignores it. If the server wants to utilize the extension for the connection, it simply adds the corresponding option in the \sphinxcode{\sphinxupquote{SYN+ACK}} segment. This is illustrated in \hyperref[\detokenize{tcp:fig-tcp-handshake-sack}]{Fig.\@ \ref{\detokenize{tcp:fig-tcp-handshake-sack}}} with the Selective Acknowledgments extension {[}\hyperlink{cite.biblio:id1948}{1}{]} as an example.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=4.5; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Client};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN\small{[seq=x]}\\\small{SACK-Permitted}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}\\\small{SACK-Permitted}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK\small{[seq=x+1,ack=y+1]}};
\end{tikzpicture}\caption{Negotiating the utilization of Selective Acknowledgments during the three\sphinxhyphen{}way handshake}\label{\detokenize{tcp:id6}}\label{\detokenize{tcp:fig-tcp-handshake-sack}}\end{figure}
\sphinxAtStartPar
A TCP connection is identified by using four fields that are included inside each TCP packet:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the client IP address

\item {} 
\sphinxAtStartPar
the server IP address

\item {} 
\sphinxAtStartPar
the client\sphinxhyphen{}selected port

\item {} 
\sphinxAtStartPar
the server port

\end{itemize}
\begin{description}
\item[{All TCP packets that belong to a connection contain these four fields in the IP and TCP header. When a host receives a packet, it uses them to match the connection to which it belongs. A TCP implementation maintains some state for each established TCP connection. This state is a data structure that contains fields which can vary from one implementation to another. The TCP specification defines some state variables that any implementation should remember. On the sender side, these include:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{snd.una}}, the oldest unacknowledged sequence number

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{snd.nxt}}, the next sequence number of be sent

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rcv.win}}, the latest window advertised by the remote host

\end{itemize}

\end{description}

\sphinxAtStartPar
A TCP sender also stores the data that has been sent but has not yet been acknowledged. It also measures the round\sphinxhyphen{}trip\sphinxhyphen{}time and its variability to set the retransmission timer and maintains several variables that are related to the congestion control scheme.

\sphinxAtStartPar
A TCP receiver also maintains state variables. These include \sphinxcode{\sphinxupquote{rcv.next}}, the next expected sequence number. Data received in sequence can be delivered to the application while out\sphinxhyphen{}of\sphinxhyphen{}sequence data must be queued.

\sphinxAtStartPar
Finally, TCP implementations store the state of the connection according to the TCP state machine {[}\hyperlink{cite.biblio:id729}{2}{]}.

\sphinxAtStartPar
TCP implementations include lots of optimizations that are outside the scope of this brief introduction. Let us know briefly describe how TCP sends data reliably. Consider a TCP connection established between a client and a server. \hyperref[\detokenize{tcp:fig-tcp-simple-data}]{Fig.\@ \ref{\detokenize{tcp:fig-tcp-simple-data}}} shows a simple data transfer between these two hosts. The sequence number of the first segment starts at \sphinxcode{\sphinxupquote{1234}}, the current value of \sphinxcode{\sphinxupquote{snd.nxt}}. For TCP, each transmitted byte consumes one sequence number. Thus, after having sent the first segment, the client’s \sphinxcode{\sphinxupquote{snd.nxt}} is set to \sphinxcode{\sphinxupquote{1238}}.  The server receives the data in sequence and immediately acknowledges it. A TCP receiver always sets the acknowledgment number of the segments that it sends with the next expected sequence number, i.e. \sphinxcode{\sphinxupquote{rcv.nxt}}.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=4; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {\small{[seq=1234,data="abcd"]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {ACK\small{[ack=1237]}};
\draw[blue,thick, ->] (\c1,\y-1) -- (\s1,\y-2) node [midway, align=left, fill=white] {\small{[seq=1238,data="efgh"]}};
\draw[blue,thick, ->] (\s1,\y-2) -- (\c1,\y-3) node [midway, align=left, fill=white] {ACK\small{[ack=1224]}};
\end{tikzpicture}\caption{TCP Reliable data transfer}\label{\detokenize{tcp:id7}}\label{\detokenize{tcp:fig-tcp-simple-data}}\end{figure}
\sphinxAtStartPar
In practice, TCP implementations use the Nagle algorithm {[}\hyperlink{cite.biblio:id831}{3}{]} and thus usually try to send full segments. They use the Maximum Segment Size (MSS) option during the handshake and PathMTU discovery the determine the largest segment which can be safely sent over a connection. Furthermore, TCP implementations usually delay acknowledgments and only acknowledge every second segment when these are received in sequence. This is illustrated in \hyperref[\detokenize{tcp:fig-tcp-data-delack}]{Fig.\@ \ref{\detokenize{tcp:fig-tcp-data-delack}}}.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=5.0; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {\small{[seq=1000,len=1460,data="x...x"]}};
\draw[blue,thick, ->] (\c1,\y-0.5) -- (\s1,\y-1.5) node [midway, align=left, fill=white] {\small{[seq=2460,len=1460,data="x...x"]}};
\draw[blue,thick, ->] (\s1,\y-1.6) -- (\c1,\y-2.6) node [midway, align=left, fill=white] {ACK\small{[ack=3920]}};
\end{tikzpicture}\caption{TCP Reliable data transfer with delayed acknowledgments.}\label{\detokenize{tcp:id8}}\label{\detokenize{tcp:fig-tcp-data-delack}}\end{figure}
\sphinxAtStartPar
TCP uses a single segment type and each segment contains both a sequence number and an acknowledgment number. The sequence number is mainly useful when a segment contains data. A receiver only processes the acknowledgment number if the \sphinxcode{\sphinxupquote{ACK}} flag is set. In practice, TCP uses cumulative acknowledgments and all the segments sent on a TCP connection have their \sphinxcode{\sphinxupquote{ACK}} flag set. The only exception is the \sphinxcode{\sphinxupquote{SYN}} segment sent by the client to initiate a connection.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=5.0; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, fill=white] {ACK\small{[seq=1234,ack=5678,len=4,data="abcd"]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, fill=white] {ACK\small{[seq=5678,ack=1238,len=2,data="ef"]}};
\draw[blue,thick, ->] (\c1,\y-2) -- (\s1,\y-3) node [midway, fill=white] {ACK\small{[seq=1238,ack=5680,len=4,data="ghij"]}};
\end{tikzpicture}\caption{TCP piggybacking.}\label{\detokenize{tcp:id9}}\label{\detokenize{tcp:fig-tcp-piggyback}}\end{figure}
\sphinxAtStartPar
TCP uses different techniques to retransmit corrupted or lost data. The TCP header contains a 16 bits checksum that is computed over the entire TCP segment and a part of the IP header. The value of this checksum is computed by the sender and checked by the receiver to detect transmission errors. TCP copes with these errors by retransmitting data. The simplest technique is to rely on a retransmission timer. TCP continuously measure the round\sphinxhyphen{}trip\sphinxhyphen{}time, i.e. the delay between the transmission of a segment and the reception of the corresponding acknowledgment. It then sets a per\sphinxhyphen{}connection retransmission timer based on its estimations of the mean rtt and its variance {[}\hyperlink{cite.biblio:id6147}{4}{]}. This is illustrated in \hyperref[\detokenize{tcp:fig-tcp-retrans}]{Fig.\@ \ref{\detokenize{tcp:fig-tcp-retrans}}} where the arrow terminated with red cross corresponds to a lost segment. Upon expiration of the retransmission timer, the client retransmits the unacknowledged segment.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=7; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick,-{Rays[color=red]}] (\c1,\y) -- (\s1,\y-1) node [midway, fill=white] {ACK\small{[seq=1234,ack=5678,len=4,data="abcd"]}};
\draw[black,thick,<->]  (\c1-0.5,\y) -- (\c1-0.5,\y-3) node [midway, fill=white] {retransmission timer};
\draw[blue,thick, ->] (\c1,\y-3) -- (\s1,\y-4) node [midway, fill=white]  {ACK\small{[seq=1234,ack=5678,len=4,data="abcd"]}};
\draw[blue,thick, ->] (\s1,\y-4.1) -- (\c1,\y-5) node [midway, fill=white] {ACK\small{[seq=5678,ack=1238]}};
\end{tikzpicture}\caption{TCP protects data by a retransmission timer}\label{\detokenize{tcp:id10}}\label{\detokenize{tcp:fig-tcp-retrans}}\end{figure}
\sphinxAtStartPar
For performance reasons, TCP implementations try to avoid relying on the retransmission timer to retransmit the lost segments. Modern TCP implementations use selective acknowledgments which can be negotiated during the handshake. This is illustrated in \hyperref[\detokenize{tcp:fig-tcp-retrans-sack}]{Fig.\@ \ref{\detokenize{tcp:fig-tcp-retrans-sack}}}. A selective acknowledgment reports blocks of sequence number that have been received correctly by the receiver. Upon reception of the \sphinxcode{\sphinxupquote{SACK}} option, the sender knows that sequence numbers \sphinxcode{\sphinxupquote{1234\sphinxhyphen{}1237}} have not been received while sequence numbers \sphinxcode{\sphinxupquote{1238\sphinxhyphen{}1250}} have been correctly received.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=8; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick,-{Rays[color=red]}] (\c1,\y) -- (\s1,\y-1) node [midway, fill=white] {\small{[seq=1234,ack=5678,data="abcd"]}};
\draw[blue,thick, ->] (\c1,\y-1) -- (\s1,\y-2) node [midway, fill=white]  {\small{[seq=1234,data="efgh"]}};
\draw[blue,thick, ->] (\c1,\y-2) -- (\s1,\y-3) node [midway, fill=white]  {\small{[seq=1238,data="ijkl"]}};
 \draw[blue,thick, ->] (\c1,\y-2) -- (\s1,\y-3) node [midway, fill=white]  {\small{[seq=1242,data="mnop"]}};
\draw[blue,thick, ->] (\c1,\y-3) -- (\s1,\y-4) node [midway, fill=white]  {\small{[seq=1246,data="qrst"]}};
\draw[blue,thick, ->] (\s1,\y-4.1) -- (\c1,\y-5) node [midway, fill=white] {ACK\small{[ack=1234]}SACK[1238:1250]};
\draw[blue,thick, ->] (\c1,\y-5.1) -- (\s1,\y-6) node [midway, fill=white]  {\small{[seq=1234,ack=5678,data="abcd"]}};
\end{tikzpicture}\caption{TCP leverages selective acknowledgments to retransmit lost data}\label{\detokenize{tcp:id11}}\label{\detokenize{tcp:fig-tcp-retrans-sack}}\end{figure}
\sphinxAtStartPar
When the client and the sender have exchanged all the required data, they can terminate the connection. TCP supports two different methods to terminate a connection. The reliable manner is that each host closes its direction of data transfer by sending a segment with the \sphinxcode{\sphinxupquote{FIN}} flag set. The sequence number of this segment marks the end of the data transfer and the recipient of the segment acknowledges it once it has delivered all the data up to the sequence number of the \sphinxcode{\sphinxupquote{FIN}} segment to its application. The release of a TCP connection is illustrated in \hyperref[\detokenize{tcp:fig-tcp-fin}]{Fig.\@ \ref{\detokenize{tcp:fig-tcp-fin}}}. To reduce the size of the figure, we have set the \sphinxcode{\sphinxupquote{FIN}} flag in segments that contains data. The server considers the connection to be closed upon reception of the \sphinxcode{\sphinxupquote{FIN+ACK}} segment. It discards the state that it maintained for this now closed TCP connection. The client also considers the connection to be closed when it sends the \sphinxcode{\sphinxupquote{FIN+ACK}} segment since all data has been acknowledged. However, it does not immediately discard the state for this connection because it needs to be able to retransmit the \sphinxcode{\sphinxupquote{FIN+ACK}} segment in case it did not reach the server.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=6; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick,->] (\c1,\y) -- (\s1,\y-1) node [midway, fill=white] {FIN\small{[seq=1234,data="abcd"]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, fill=white]  {ACK \small{[ack=1239]}};
\draw[blue,thick, ->] (\s1,\y-3) -- (\c1,\y-4) node [midway, fill=white]  {FIN\small{[seq=5678,date="xyz"]}};
\draw[blue,thick,->] (\c1,\y-4) -- (\s1,\y-5) node [midway, fill=white] {FIN+ACK\small{[seq=1239,ack=5681]}};
\end{tikzpicture}\caption{Closing a TCP connection using the \sphinxcode{\sphinxupquote{FIN}} flag}\label{\detokenize{tcp:id12}}\label{\detokenize{tcp:fig-tcp-fin}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=4; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick,->] (\c1,\y) -- (\s1,\y-1) node [midway, fill=white] {\small{[seq=1234,data="abcd"]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, fill=white]  {RST\small{[ack=1239]}};
\end{tikzpicture}\caption{Closing a TCP connection using a \sphinxcode{\sphinxupquote{RST}} segment}\label{\detokenize{tcp:id13}}\label{\detokenize{tcp:fig-tcp-rst}}\end{figure}

\chapter{Multipath TCP}
\label{\detokenize{mptcp:multipath-tcp}}\label{\detokenize{mptcp::doc}}
\sphinxAtStartPar
Multipath TCP {[}\hyperlink{cite.biblio:id8500}{5}{]} is an extension to the TCP protocol {[}\hyperlink{cite.biblio:id729}{2}{]} that was described in chapter {\hyperref[\detokenize{tcp:chapter-tcp}]{\sphinxcrossref{\DUrole{std,std-ref}{The Transmission Control Protocol (TCP)}}}}. We start with an overview of Multipath TCP. Then we explain how a Multipath TCP connection can be established. Then we analyze how data is exchanged over different paths and explain the multipath congestion control schemes. Finally, we explain how Multipath TCP connections can be terminated.


\section{A brief overview of Multipath TCP}
\label{\detokenize{mptcp:a-brief-overview-of-multipath-tcp}}\label{\detokenize{mptcp:mptcp-overview}}
\sphinxAtStartPar
The main design objective for Multipath TCP {[}\hyperlink{cite.biblio:id6658}{6}{]} was to enable hosts to exchange the packets that belong to a single TCP connection over different network paths. Several definitions are possible for a network path. Considering a TCP connection between a client and a server, a network path can be defined as the succession of the links and routers that create a path between the client and the server. For example, in \hyperref[\detokenize{mptcp:fig-simple-network}]{Fig.\@ \ref{\detokenize{mptcp:fig-simple-network}}}, there are many paths between the client host \sphinxtitleref{C} and the server \sphinxtitleref{S}, e.g. \(C \rightarrow R1 \rightarrow R2 \rightarrow R4 \rightarrow S\) and \(C \rightarrow R1 \rightarrow R3 \rightarrow R4 \rightarrow S\), but also \(C \rightarrow R1 \rightarrow R3 \rightarrow R5 \rightarrow R4 \rightarrow S\) or even \(C \rightarrow R1 \rightarrow R2 \rightarrow R4 \rightarrow R3 \rightarrow R5 \rightarrow R4 \rightarrow S\).
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzset{router/.style = {rectangle, draw, text centered, minimum height=2em}, }
\tikzset{host/.style = {circle, draw, text centered, minimum height=2em}, }
\node[host] (C) {C};
\node[router, right of=C] (R1) {R1};
\node[router, right=of R1] (R3) {R3};
\node[router, right=of R3] (R5) {R5};
\node[router, below=of R1] (R2) {R2};
\node[router, below=of R3] (R4) {R4};
\node[host, right of=R4] (S) {S};
\path[draw,thick]
(C) edge (R1)
(R1) edge (R2)
(R3) edge (R1)
(R2) edge (R4)
(R4) edge (R3)
(R4) edge (R5)
(R3) edge (R5)
(R4) edge (S);
\end{tikzpicture}\caption{A simple network providing multiple paths between \(C\) and \(S\)}\label{\detokenize{mptcp:id52}}\label{\detokenize{mptcp:fig-simple-network}}\end{figure}
\sphinxAtStartPar
During the first discussions on Multipath TCP within the IETF, there was a debate on the types of paths that Multipath TCP could use in IP networks. Although networks provide a wide range of paths between a source and a destination, it is not necessarily simple to use all these paths in a pure IP network. Looking a \hyperref[\detokenize{mptcp:fig-simple-network}]{Fig.\@ \ref{\detokenize{mptcp:fig-simple-network}}} and assuming that all links have the same IGP weight, packets sent by \sphinxtitleref{C} will follow one of the two shortest paths, i.e. \(C \rightarrow R1 \rightarrow R2 \rightarrow R4 \rightarrow S\) or \(C \rightarrow R1 \rightarrow R3 \rightarrow R4 \rightarrow S\). Since routers usually use hash\sphinxhyphen{}based load\sphinxhyphen{}balancing {[}\hyperlink{cite.biblio:id2922}{7}{]} to distribute packets over equal cost paths, all the packets from a given connection will follow either the first or the second shortest path. In most networks, the path followed by a TCP connection will only change if there are link or router failures on this particular path.

\sphinxAtStartPar
When Multipath TCP was designed, the IETF did not want to design techniques to enable the transport layer to specify the paths that packets should follow. They opted for a very conservative definition of the paths that Multipath TCP can use {[}\hyperlink{cite.biblio:id6033}{8}{]}. Multipath TCP assumes that the endpoints of a TCP connection are identified by their IP addresses. If two hosts want to exchange packets over different paths, then at least one of them must have two or more IP addresses. This covers two very important use cases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
mobile devices like the smartphones that have a cellular and a Wi\sphinxhyphen{}Fi network interface each identified by its own IP address

\item {} 
\sphinxAtStartPar
dual\sphinxhyphen{}stack hosts that have both an IPv4 and an IPv6 address

\end{itemize}

\sphinxAtStartPar
In this document, we will often use smartphones to illustrate Multipath TCP client hosts. This corresponds to a widely deployed use case that simplifies many of the examples, but is not the only possible deployment.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Using non\sphinxhyphen{}equal cost paths with Multipath TCP

\sphinxAtStartPar
When Multipath TCP was designed, there was no standardized solution that enabled a host to control the path followed by its packets inside a network. This is slowly changing. First, the IETF has adopted the Segment Routing architecture {[}\hyperlink{cite.biblio:id8227}{9}{]}. This architecture is a modern version of source routing which can be used in MPLS and IPv6 networks. In particular, using the IPv6 Segment Routing Header {[}\hyperlink{cite.biblio:id8570}{10}{]}, a host can decide the path that its packets will follow inside the network. This opens new possibilities for Multipath TCP. Some of these possibilities are explored by the Path Aware Networking Research Group of the Internet Research Task Force.
\end{sphinxadmonition}

\sphinxAtStartPar
A second important design question for the Multipath TCP designers was how use two or more paths for a single connection ? As an example, let us consider a smartphone that interacts with a server. This smartphone has two different IP addresses: one over its Wi\sphinxhyphen{}Fi interface and one over its cellular interface. A naive way to use these two networks would be to operate as shown \hyperref[\detokenize{mptcp:fig-mptcp-naive}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-naive}}}. The smartphone would initiate a TCP connection over its Wi\sphinxhyphen{}Fi interface as shown in blue in \hyperref[\detokenize{mptcp:fig-mptcp-naive}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-naive}}}. This handshake creates a connection and thus some shared state between the smartphone and the server. Given this state, could the smartphone simply sent the next date over the cellular interface (shown in red in \hyperref[\detokenize{mptcp:fig-mptcp-naive}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-naive}}}) ?
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1; \c2=1.5; \s1=8; \s2=8.5; \max=7; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Smartphone};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[red,thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\draw[black,thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN\small{[seq=x]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK\small{[seq=x+1,ack=y+1]}};
\draw[blue,thick, ->] (\c1,\y-3) -- (\s1,\y-4) node [midway, align=left, fill=white] {Data\small{[seq=x+1]}};
\draw[red,thick, ->] (\c2,\y-4) -- (\s1,\y-5) node [midway, align=left, fill=white] {Data\small{[seq=x+2]}};
\end{tikzpicture}\caption{A naive approach to create a Multipath TCP connection}\label{\detokenize{mptcp:id53}}\label{\detokenize{mptcp:fig-mptcp-naive}}\end{figure}
\sphinxAtStartPar
Unfortunately, this utilization of the two paths between the smartphone and the server poses different problems. First, the server must be able to accept the packet sent by the smartphone over the cellular interface and associate it with the connection created over the Wi\sphinxhyphen{}Fi interface. However, the packets sent over the cellular interface use a different source address than those sent over the Wi\sphinxhyphen{}Fi interface. When the server receives such a packet, how can it be associated with an existing connection ? If the server blindingly accept this packet from another address than the one used during the handshake, then there are obvious security risks. By sending a single packet, an attacker could inject data inside an existing connection. Furthermore, he could cause a denial of service attack by sending a spoofed packet in an existing connection that requests the server to send a large volume of data to the spoofed address. Furthermore, a middlebox such as a firewall on the cellular path between the smartphone and the server could block the packet because it does not belong to a TCP connection created on the cellular path.

\sphinxAtStartPar
To cope with this problem, the Multipath TCP designers opted for an architecture where a Multipath TCP connection combines several TCP connections that are called subflows over the different paths. In the above example, the smartphone would first create a connection over the Wi\sphinxhyphen{}Fi interface. It would later initiate a TCP connection over its cellular interface and use Multipath TCP to link it to the connection created over the Wi\sphinxhyphen{}Fi interface.

\sphinxAtStartPar
A Multipath TCP connection starts with a three\sphinxhyphen{}way handshake like a regular TCP connection. As with all TCP extensions, the client uses an option in the \sphinxcode{\sphinxupquote{SYN}} to indicate its willingness to use the multipath extensions. The server confirms that it agrees to use this extension by sending the same option in the \sphinxcode{\sphinxupquote{SYN+ACK}}.  This is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-capable-join}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-capable-join}}} where the client sends a \sphinxcode{\sphinxupquote{SYN}} with the \sphinxcode{\sphinxupquote{MPC}} option to negotiate a Multipath TCP connection with a server. If the server replies with the same option, the handshake succeeds and creates the first subflow belonging to this Multipath TCP connection. The client and the server can send data over this connection as over any TCP connection. To use a second path, the client (or the server), must initiate another TCP handshake over the new path. The \sphinxcode{\sphinxupquote{SYN}} sent over this second path uses the \sphinxcode{\sphinxupquote{MPJ}} option to indicate that this is an additional subflow that must be linked to an existing Multipath TCP connection. This is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-capable-join}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-capable-join}}}.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1; \c2=1.5; \s1=8; \s2=8.5; \max=10; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Smartphone};
\node [black, fill=white] at (\s1,\max) {Server};
\node [blue, fill=white] at (\c1, \max-0.5) {$IP_{\alpha}$};
\node [red, fill=white] at (\c2, \max-0.5) {$IP_{\beta}$};
\node [black, fill=white] at (\s1, \max-0.5) {$IP_{S}$};
\draw[blue,thick,->] (\c1,\max-0.75) -- (\c1,0.75);
\draw[red,thick,->] (\c2,\max-0.75) -- (\c2,0.75);
\draw[black,thick,->] (\s1,\max-0.75) -- (\s1,0.75);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=center, fill=white] {SYN\small{[seq=x]}\\\small{MPC}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=center, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}\\\small{MPC}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=center, fill=white] {ACK\small{[seq=x+1,ack=y+1]}};
\draw[blue,thick, ->] (\c1,\y-3) -- (\s1,\y-4) node [midway, align=center, fill=white] {Data\small{[seq=x+1]}};
\draw[red,thick, ->] (\c2,\y-4) -- (\s1,\y-5) node [midway, align=center, fill=white] {SYN\small{[seq=p]}\\\small{MPJ}};
\draw[red,thick, ->] (\s1,\y-5) -- (\c2,\y-6) node [midway, align=center, fill=white] {SYN+ACK\small{[seq=q,ack=p+1]}\\\small{MPJ}};
\draw[red,thick, ->] (\c2,\y-6) -- (\s1,\y-7) node [midway, align=center, fill=white] {ACK\small{[seq=p+1,ack=q+1]}};
\draw[red,thick, ->] (\c2,\y-7) -- (\s1,\y-8) node [midway, align=center, fill=white] {Data\small{[seq=p+1]}};
\end{tikzpicture}\caption{A Multipath TCP connection with two subflows}\label{\detokenize{mptcp:id54}}\label{\detokenize{mptcp:fig-mptcp-capable-join}}\end{figure}
\sphinxAtStartPar
These two three\sphinxhyphen{}way handshakes create two TCP connections called subflows in the Multipath TCP terminology. It is useful to analyze how these two connections are identified on the server. A host identifies a TCP connection using four identifiers that are present in all the packets of this connection:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the local IP address

\item {} 
\sphinxAtStartPar
the remote IP address

\item {} 
\sphinxAtStartPar
the local port

\item {} 
\sphinxAtStartPar
the remote port

\end{itemize}

\sphinxAtStartPar
Assume that the client uses IP address \(IP_{\alpha}\) on its Wi\sphinxhyphen{}Fi interface and \(IP_{\beta}\) on its cellular interface and that \(p\) is the port used by the server. If the client used port \(p_1\) to create the initial subflow, then the identifier of this subflow on the server is \(<IP_{S},IP_{\alpha},p,p_{1}>\). Similarly, the second subflow is identified by the \(<IP_{S},IP_{\beta},p,p_{2}>\) tuple on the server. Note that these two connection identifiers differ by at least one IP address as specified in {[}\hyperlink{cite.biblio:id6033}{8}{]}.

\sphinxAtStartPar
A server usually manages a large number of simultaneous connections. Furthermore, a client may establish several connections with the same server. To associate a new subflow with an existing Multipath TCP connection, a server must be able to link an incoming \sphinxcode{\sphinxupquote{SYN}} with the corresponding Multipath TCP connection. For this, the client must include an identifier of the associated Multipath TCP connection in its \sphinxcode{\sphinxupquote{MPJ}} option. This identifier must unambiguously identify the corresponding Multipath TCP connection on the server.

\sphinxAtStartPar
A first possible identifier is the four tuple that identifies the initial subflow, i.e. \(<IP_{S},IP_{\alpha},p,p_{1}>\). If the server received this identifier in the \sphinxcode{\sphinxupquote{MPJ}} option, it could link the new subflow to the previous one. Unfortunately, this solution does not work in today’s Internet. The main concern comes from the middleboxes such as NATs and transparent proxies. To illustrate the problem, consider a simple NAT, such as the one used on most home Wi\sphinxhyphen{}Fi access points. \hyperref[\detokenize{mptcp:fig-nat-interference}]{Fig.\@ \ref{\detokenize{mptcp:fig-nat-interference}}} illustrates a TCP handshake in such an environment.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzmath{\c1=1; \c2=1.5; \s1=8; \s2=8.5; \max=5; \nat=4.5;}
\node [red, fill=white,align=center] at (\nat,\max) {NAT \\$IP_{N}$};
\node [black, fill=white,align=center] at (\c1,\max) {Smartphone \\ $IP_{p}$};
\node [black, fill=white,align=center] at (\s1,\max) {Server \\$IP_{S}$};
\draw[black,thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,dashed,very thick,-] (\nat,\max-0.5) -- (\nat,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\nat,\y-0.5) node [midway, align=center, fill=white] {$IP_{P}\rightarrow IP_{S}$\\SYN};
\draw[blue,thick, ->] (\nat,\y-0.5) -- (\s1,\y-1) node [midway, align=center, fill=white] {$IP_{N}\rightarrow IP_{S}$\\SYN};
\draw[blue,thick, ->] (\s1,\y-1.5) -- (\nat,\y-2) node [midway, align=center, fill=white] {$IP_{S}\rightarrow IP_{N}$\\SYN+ACK};
\draw[blue,thick, ->] (\nat,\y-2) -- (\c1,\y-2.5) node [midway, align=center, fill=white] {$IP_{S}\rightarrow IP_{P}$\\SYN+ACK};
\draw[blue,thick, ->] (\c1,\y-3) -- (\nat,\y-3.5) node [midway, align=center, fill=white] {$IP_{P}\rightarrow IP_{S}$\\ACK};
\draw[blue,thick, ->] (\nat,\y-3.5) -- (\s1,\y-4) node [midway, align=center, fill=white] {$IP_{N}\rightarrow IP_{S}$\\ACK};
\end{tikzpicture}\caption{Network Address Translation interferes with TCP}\label{\detokenize{mptcp:id55}}\label{\detokenize{mptcp:fig-nat-interference}}\end{figure}
\sphinxAtStartPar
The smartphone uses a private IP address, \(IP_{P}\) and the NAT uses a public address \(IP_{N}\). If we assume that the NAT only changes the client’s IP address, then the connection is identified by the \(<IP_{P},IP_{S},p,p_{1}>\) tuple on the smartphone and \(<IP_{S},IP_{N},p,p_{1}>\) on the server. Note some NATs also change the client port. If the smartphone places its local connection identifier inside an \sphinxcode{\sphinxupquote{MPJ}} option, the server might not be able to recognize the corresponding connection in the \sphinxcode{\sphinxupquote{SYN}} packets that it received.

\sphinxAtStartPar
To cope with this problem, Multipath TCP uses a local identifier, called \sphinxtitleref{token} in the Multipath TCP specification, to identify each Multipath TCP connection. The client assigns its token when it initiates a new Multipath TCP connection. A server assigns its token when it accepts a new Multipath TCP connection. These two tokens are chosen independently by the client and the server. For security reasons, these tokens should be random. The \sphinxcode{\sphinxupquote{MPJ}} option contains the token assigned by the remote host. This is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-capable-join-token}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-capable-join-token}}}. The server assigns token \sphinxtitleref{456} to the Multipath TCP connection created as the first subflow. It informs the smartphone by sending this token in its \sphinxcode{\sphinxupquote{MPC}} option in the \sphinxcode{\sphinxupquote{SYN+ACK}}. When the client creates the second subflow, it includes its token in the \sphinxcode{\sphinxupquote{MPJ}} option of its \sphinxcode{\sphinxupquote{SYN}}.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1; \c2=1.5; \s1=8; \s2=8.5; \max=10; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Smartphone};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[red,thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\draw[black,thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=center, fill=white] {SYN\small{[seq=x]}\\\small{MPC[token=123]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=center, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}\\\small{MPC[token=456]}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=center, fill=white] {ACK\small{[seq=x+1,ack=y+1]}};
\draw[blue,thick, ->] (\c1,\y-3) -- (\s1,\y-4) node [midway, align=center, fill=white] {Data\small{[seq=x+1]}};
\draw[red,thick, ->] (\c2,\y-4) -- (\s1,\y-5) node [midway, align=center, fill=white] {SYN\small{[seq=p]}\\\small{MPJ[token=456]}};
\draw[red,thick, ->] (\s1,\y-5) -- (\c2,\y-6) node [midway, align=center, fill=white] {SYN+ACK\small{[seq=q,ack=p+1]}\\\small{MPJ[\ldots]}};
\draw[red,thick, ->] (\c2,\y-6) -- (\s1,\y-7) node [midway, align=center, fill=white] {ACK\small{[seq=p+1,ack=q+1]}};
\end{tikzpicture}\caption{The tokens exchanged during the handshake allow to associate subsequent subflows to existing Multipath TCP connections}\label{\detokenize{mptcp:id56}}\label{\detokenize{mptcp:fig-mptcp-capable-join-token}}\end{figure}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Multipath TCP in datacenters

\sphinxAtStartPar
The Multipath TCP architecture {[}\hyperlink{cite.biblio:id6033}{8}{]} assumes that at least one of the communicating hosts use different IP addresses to identify the different paths used by a Multipath TCP connection. In practice, this architectural requirement is not always enforced by Multipath TCP implementations. A Multipath TCP implementation can combine different subflows into one Multipath TCP connection provided that each subflow is identified by a different four\sphinxhyphen{}tuple. Two subflows between two communicating hosts can differ in their client\sphinxhyphen{}selected ports. This solution has been chosen when Multipath TCP was proposed to mitigate congestion in datacenter networks {[}\hyperlink{cite.biblio:id8933}{11}{]}.

\sphinxAtStartPar
Several designs exist for datacenter networks, but the fat\sphinxhyphen{}tree architecture shown in \hyperref[\detokenize{mptcp:fig-fat-tree}]{Fig.\@ \ref{\detokenize{mptcp:fig-fat-tree}}} is a very popular one.
\begin{figure}[H]\centering\capstart \begin{tikzpicture}[node distance=4cm]
 \tikzset{router/.style = {rectangle, draw, text centered, minimum height=2em}, }
 \tikzset{host/.style = {circle, draw, text centered, minimum height=2em}, }
 \node[router] (C1) {C1};
 \node[router, right= 6cm of C1] (C2) {C2};
 \node[router, below left=1cm of C1] (A1) {A1};
 \node[router, below right= 1cm of C1] (A2) {A2};
 \node[router, below left= 1cm of C2] (A3) {A3};
 \node[router, below right= 1cm of C2] (A4) {A4};
 \node[router, below= 1cm of A1] (E1) {E1};
 \node[router, below= 1cm of A2] (E2) {E2};
 \node[router, below= 1cm of A3] (E3) {E3};
 \node[router, below= 1cm of A4] (E4) {E4};
 \node[host, below left= 0.5cm of E1] (P1) {$\alpha$};
 \node[host, below right= 0.5cm of E1] (P2) {$\beta$};
 \node[host, below left= 0.5cm of E2] (P3) {$\gamma$};
 \node[host, below right= 0.5cm of E2] (P4) {$\delta$};
 \node[host, below left= 0.5cm of E3] (P5) {$\kappa$};
 \node[host, below right= 0.5cm  of E3] (P6) {$\nu$};
 \node[host, below left= 0.5cm of E4] (P7) {$\mu$};
 \node[host, below right= 0.5cm of E4] (P8) {$\pi$};
 \path[draw,thick]
 (P1) edge (E1)
 (P2) edge (E1)
 (P3) edge (E2)
 (P4) edge (E2)
 (P5) edge (E3)
 (P6) edge (E3)
 (P7) edge (E4)
 (P8) edge (E4)
 (E1) edge (A1)
 (E1) edge (A2)
 (E2) edge (A1)
 (E2) edge (A2)
 (E3) edge (A3)
 (E3) edge (A4)
 (E4) edge (A3)
 (E4) edge (A4)
 (A1) edge (C1)
 (A1) edge (C2)
 (A2) edge (C1)
 (A2) edge (C2)
 (A3) edge (C1)
 (A3) edge (C2)
 (A4) edge (C1)
 (A4) edge (C2);
 \end{tikzpicture}\caption{A simple datacenter network}\label{\detokenize{mptcp:id57}}\label{\detokenize{mptcp:fig-fat-tree}}\end{figure}
\sphinxAtStartPar
This network topology exposes a large number of equal cost paths between the servers that are shown using circles in \hyperref[\detokenize{mptcp:fig-fat-tree}]{Fig.\@ \ref{\detokenize{mptcp:fig-fat-tree}}}. For example, consider the paths between the \(\alpha\) and \(\pi\) hosts. The paths start at \(E1\). This router can reach \(E4\) and \(\pi\) via \(A1\) or \(A2\). Each of these two aggregation routers can reach \(\pi\) via one of the two core routers. These two routers can then balance the flows via both \(A3\) and \(A4\). There are \(2^{4}=16\) different paths between \(\alpha\) and \(\pi\) in this very small network. If each of these routers balance the incoming packets using a hash function {[}\hyperlink{cite.biblio:id2922}{7}{]} that takes as input their source and destination addresses and ports, then the subflows of a Multipath TCP connection that use different client problems will be spread evenly across the network topology.  Raiciu et al. provide simulations and measurements showing the benefits of using Multipath TCP in datacenters {[}\hyperlink{cite.biblio:id8933}{11}{]}.
\end{sphinxadmonition}

\sphinxAtStartPar
Once a Multipath TCP connection and the additional subflows have been established, we can use them to exchange data. An important point to remember is that a Multipath TCP connection provides a bidirectional bytestream service like a regular TCP connection. This service does not change even if Multipath TCP uses different subflows to carry the data between the sender and the receiver. As an example, consider a sender that sends \sphinxcode{\sphinxupquote{ABCD}} one byte at a time over a Multipath TCP connection composed of two subflows. A naive approach to send these bytes would be to simply placed them in different TCP segments. This is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-data-naive}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-data-naive}}} where we assume that the two TCP subflows have already been established.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1; \c2=1.5; \s1=8; \s2=8.5; \max=10; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Smartphone};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[red,thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\draw[black,thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=center, fill=white] {DATA\small{[seq=x,A]}};
\draw[black,thick, ->] (\s1,\y-1) -- (\s1+4,\y-1) node [midway, align=center, fill=white] {DATA.ind(A)};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=center, fill=white] {ACK\small{[ack=x+1]}};
\draw[red,thick, ->] (\c2,\y-2) -- (\s1,\y-3) node [midway, align=center, fill=white] {DATA\small{[seq=p,B]}};
\draw[black,thick, ->] (\s1,\y-3) -- (\s1+4,\y-3) node [midway, align=center, fill=white] {DATA.ind(B)};
\draw[red,thick, ->] (\s1,\y-3) -- (\c2,\y-4) node [midway, align=center, fill=white] {ACK\small{[ack=p+1]}};
\draw[blue,thick, ->] (\c1,\y-4) -- (\s1,\y-5) node [midway, align=center, fill=white] {DATA\small{[seq=x+1,C]}};
   \draw[black,thick, ->] (\s1,\y-5) -- (\s1+4,\y-5) node [midway, align=center, fill=white] {DATA.ind(C)};
\draw[blue,thick, ->] (\s1,\y-5) -- (\c1,\y-6) node [midway, align=center, fill=white] {ACK\small{[ack=x+2]}};
\draw[red,thick, ->] (\c2,\y-6) -- (\s1,\y-7) node [midway, align=center, fill=white] {DATA\small{[seq=p+1,D]}};
   \draw[black,thick, ->] (\s1,\y-7) -- (\s1+4,\y-7) node [midway, align=center, fill=white] {DATA.ind(D)};
\draw[red,thick, ->] (\s1,\y-7) -- (\c2,\y-8) node [midway, align=center, fill=white] {ACK\small{[acl=p+2]}};
\end{tikzpicture}\caption{A naive approach to send data over a Multipath TCP connection}\label{\detokenize{mptcp:id58}}\label{\detokenize{mptcp:fig-mptcp-data-naive}}\end{figure}
\sphinxAtStartPar
In this example, the Smartphone slowly sends data in sequence. The server receives the data in sequence over the two subflows and the server could simply deliver the data as soon as it arrives over each subflow. This is illustrated with the \sphinxcode{\sphinxupquote{DATA.ind(...)}} primitives that represent the delivery of the data to the server application. However, consider now that the first packet sent on the red subflow is lost and is retransmitted together with the fourth byte as shown in \hyperref[\detokenize{mptcp:fig-mptcp-data-naive-2}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-data-naive-2}}}.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1; \c2=1.5; \s1=8; \s2=8.5; \max=10; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Smartphone};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[red,thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\draw[black,thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=center, fill=white] {DATA\small{[seq=x,A]}};
\draw[black,thick, ->] (\s1,\y-1) -- (\s1+4,\y-1) node [midway, align=center, fill=white] {DATA.ind(A)};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=center, fill=white] {ACK\small{[ack=x+1]}};
\draw[red,thick, -Circle] (\c2,\y-2) -- (\s1-1,\y-2.8) node [midway, align=center, fill=white] {DATA\small{[seq=p,bseq=1,B]}};
\draw[blue,thick, ->] (\c1,\y-4) -- (\s1,\y-5) node [midway, align=center, fill=white] {DATA\small{[seq=x+1,C]}};
\draw[black,thick, ->] (\s1,\y-5) -- (\s1+4,\y-5) node [midway, align=center, fill=white] {DATA.ind(C) ????};
\draw[blue,thick, ->] (\s1,\y-5) -- (\c1,\y-6) node [midway, align=center, fill=white] {ACK\small{[ack=x+2]}};
\draw[red,thick, ->] (\c2,\y-6) -- (\s1,\y-7) node [midway, align=center, fill=white] {DATA\small{[seq=p,BD]}};
\draw[black,thick, ->] (\s1,\y-7) -- (\s1+4,\y-7) node [midway, align=center, fill=white] {DATA.ind(BD) ????};
\draw[red,thick, ->] (\s1,\y-7) -- (\c2,\y-8) node [midway, align=center, fill=white] {ACK\small{[acl=p+2]}};
\end{tikzpicture}\caption{A naive approach to send data over a Multipath TCP connection}\label{\detokenize{mptcp:id59}}\label{\detokenize{mptcp:fig-mptcp-data-naive-2}}\end{figure}
\sphinxAtStartPar
In \hyperref[\detokenize{mptcp:fig-mptcp-data-naive-2}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-data-naive-2}}}, it is clear that the server cannot simply deliver the data as soon as it receives it to its application. If the server behaves this way, it will deliver \sphinxcode{\sphinxupquote{ACBD}} to its application instead of the \sphinxcode{\sphinxupquote{ABCD}} bytestream send by the smartphone. To cope with the reordering of the data sent over the different subflows, Multipath TCP includes bytestream\sphinxhyphen{}level data sequence numbers that enable it to preserve the ordering of the data sent over the bytestream. This is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-data-seq}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-data-seq}}} with the bytestream\sphinxhyphen{}level sequence number shown as \sphinxcode{\sphinxupquote{bseq}}. We will detail later how this sequence number is exactly transported by Multipath TCP.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1; \c2=1.5; \s1=8; \s2=8.5; \max=10; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Smartphone};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[red,thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\draw[black,thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=center, fill=white] {DATA\small{[seq=x,bseq=0,A]}};
\draw[black,thick, ->] (\s1,\y-1) -- (\s1+4,\y-1) node [midway, align=center, fill=white] {DATA.ind(A)};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=center, fill=white] {ACK\small{[ack=x+1]}};
\draw[red,thick, -Circle] (\c2,\y-2) -- (\s1-1,\y-2.8) node [midway, align=center, fill=white] {DATA\small{[seq=p,bseq=1,B]}};
\draw[blue,thick, ->] (\c1,\y-4) -- (\s1,\y-5) node [midway, align=center, fill=white] {DATA\small{[seq=x+1,bseq=2,C]}};
\draw[blue,thick, ->] (\s1,\y-5) -- (\c1,\y-6) node [midway, align=center, fill=white] {ACK\small{[ack=x+2]}};
\draw[red,thick, ->] (\c2,\y-5.5) -- (\s1,\y-6.5) node [midway, align=center, fill=white] {DATA\small{[seq=p,bseq=1,BC]}};
\draw[black,thick, ->] (\s1,\y-6.5) -- (\s1+4,\y-6.5) node [midway, align=center, fill=white] {DATA.ind(BC)};
\draw[red,thick, ->] (\c2,\y-6) -- (\s1,\y-7) node [midway, align=center, fill=white] {DATA\small{[seq=p,bseq=3,D]}};
\draw[black,thick, ->] (\s1,\y-7) -- (\s1+4,\y-7) node [midway, align=center, fill=white] {DATA.ind(D)};
\draw[red,thick, ->] (\s1,\y-7) -- (\c2,\y-8) node [midway, align=center, fill=white] {ACK\small{[acl=p+2]}};
\end{tikzpicture}\caption{A naive approach to send data over a Multipath TCP connection}\label{\detokenize{mptcp:id60}}\label{\detokenize{mptcp:fig-mptcp-data-seq}}\end{figure}
\sphinxAtStartPar
Thanks to the bytestream sequence number, the server can reorder the data received over the different subflows and preserve the ordering in the bytestream.


\section{Creating a Multipath TCP connection}
\label{\detokenize{mptcp:creating-a-multipath-tcp-connection}}\label{\detokenize{mptcp:mptcp-initial-handshake}}
\sphinxAtStartPar
Before delving into the details of how a Multipath TCP connection is created, let use first analyze the main requirements of this establishment and how they can be met without considering all the protocol details. During the three\sphinxhyphen{}way handshake, TCP hosts agree to establishment a connection, select the initial sequence number in each direction and negotiate the utilization of TCP extensions. In addition to these objectives, the handshake used by Multipath TCP also allows the communicating hosts to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
agree to use the Multipath TCP extension

\item {} 
\sphinxAtStartPar
exchange the tokens used to identify the connection

\item {} 
\sphinxAtStartPar
agree on initial bytestream sequence numbers

\end{itemize}

\sphinxAtStartPar
To meet the first objective, the client simply needs to send a Multipath TCP option (\sphinxcode{\sphinxupquote{MPO}}) in its \sphinxcode{\sphinxupquote{SYN}}. If the server supports Multipath TCP, it will respond with a \sphinxcode{\sphinxupquote{SYNC+AC}} that carries this option.

\sphinxAtStartPar
To meet the second objective, the simplest solution is reserve some space, e.g. 64 bits, in the \sphinxcode{\sphinxupquote{MPO}} option to encode the token chosen by the host that sends the \sphinxcode{\sphinxupquote{SYN}} or \sphinxcode{\sphinxupquote{SYN+ACK}}. With this approach, each host can autonomously select the token that it uses to identify each Multipath TCP connection. To meet the third objective, the simplest solution is also to place the initial sequence number in the \sphinxcode{\sphinxupquote{MPO}} option. \hyperref[\detokenize{mptcp:fig-tcp-handshake-mpo}]{Fig.\@ \ref{\detokenize{mptcp:fig-tcp-handshake-mpo}}} illustrates a handshake using the \sphinxcode{\sphinxupquote{MPO}} option.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=11; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Client};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN\small{[seq=x]}\\\small{MPO[$Client_{token}$,$Client_{bseq}$]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}\\\small{MPO[$Server_{token}$,$Server_{bseq}$]}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK\small{[seq=x+1,ack=y+1]}};
\draw[red,thick, ->] (\c2,\y-4) -- (\s1,\y-5) node [midway, align=center, fill=white] {SYN\small{[seq=p]}\\\small{MP\_Join[token=$Server_{token}$]}};
\draw[red,thick, ->] (\s1,\y-5) -- (\c2,\y-6) node [midway, align=center, fill=white] {SYN+ACK\small{[seq=q,ack=p+1]}\\\small{MP\_Join[\ldots]}};
\draw[red,thick, ->] (\c2,\y-6) -- (\s1,\y-7) node [midway, align=center, fill=white] {ACK\small{[seq=p+1,ack=q+1]}};
\end{tikzpicture}\caption{Opening a Multipath TCP connection with a MPO option}\label{\detokenize{mptcp:id61}}\label{\detokenize{mptcp:fig-tcp-handshake-mpo}}\end{figure}
\sphinxAtStartPar
The Multipath TCP working group was worried about the risk of attacks with this approach. When the smartphone creates an additional subflow, it includes the token allocated by the server inside the \sphinxcode{\sphinxupquote{MP\_JOIN}} option. This token serves two different purposes. First, it identifies the relevant Multipath TCP connection on the server. Second, it also “authenticates” that the \sphinxcode{\sphinxupquote{SYN}} also originates from this client. Authenticating the client is a key concern from a security viewpoint. The main risk is that an on\sphinxhyphen{}path attacker who has observed the token in the \sphinxcode{\sphinxupquote{MP\_JOIN}} option can reuse it to create additional subflows from any other source. To cope with this problem, Multipath TCP relies on a shared secret that the client and the server exchange during the initial handshake. The client proposes one halve of the secret and the server the other halve. This is illustrated in \hyperref[\detokenize{mptcp:fig-tcp-handshake-mpo-secret}]{Fig.\@ \ref{\detokenize{mptcp:fig-tcp-handshake-mpo-secret}}}. The client proposes its part of the shared secret in the \sphinxcode{\sphinxupquote{SYN}} (\(Client_{secret}\)). The server replies with its part of the secret in the \sphinxcode{\sphinxupquote{SYN+ACK}}.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=9; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Client};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[blue,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN\small{[seq=x]}\\\small{MPO[$Client_{token}$,$Client_{bseq}$,$Client_{secret}$]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}\\\small{MPO[$Server_{token}$,$Server_{bseq}$,$Server_{secret}$]}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK\small{[seq=x+1,ack=y+1]}};
\draw[red,thick, ->] (\c2,\y-4) -- (\s1,\y-5) node [midway, align=center, fill=white] {SYN\small{[seq=p]}\\\small{MP\_Join[$Server_{token}$,$Client_{random}$]}};
\draw[red,thick, ->] (\s1,\y-5) -- (\c2,\y-6) node [midway, align=center, fill=white] {SYN+ACK\small{[seq=q,ack=p+1]}\\\small{MP\_Join[$Server_{random}$,HMAC1]}};
\draw[red,thick, ->] (\c2,\y-6) -- (\s1,\y-7) node [midway, align=center, fill=white] {ACK\small{[seq=p+1,ack=q+1]}\\\small{MP\_Join[HMAC2]}};
\node[black,fill=white,align=right] at (\c1,0) {HMAC1=HMAC(key=$Server_{secret}$||$Client_{Secret}$,\\msg=$Server_{random}||Client_{random}$)};
\node[black,fill=white,align=right] at (\c1,-1)  {HMAC2=HMAC(key=$Client_{secret}$||$Server_{Secret}$,\\msg=$Client_{random}||Server_{random}$)};
\end{tikzpicture}\caption{Creating a Multipath TCP connection with a MPO option}\label{\detokenize{mptcp:id62}}\label{\detokenize{mptcp:fig-tcp-handshake-mpo-secret}}\end{figure}
\sphinxAtStartPar
Using these two components of the shared secret, the client and the server must be able to authenticate the additional subflows without revealing the shared secret to an attacker who is able to capture packets on the path of the additional subflow. Multipath TCP requires each host to perform a HMAC {[}\hyperlink{cite.biblio:id2034}{12}{]} of a random number to confirm their knowledge of the shared secret. This is illustrated in the second part of \hyperref[\detokenize{mptcp:fig-tcp-handshake-mpo-secret}]{Fig.\@ \ref{\detokenize{mptcp:fig-tcp-handshake-mpo-secret}}}. To create the additional subflow, the client send a \sphinxcode{\sphinxupquote{SYN}} with the \sphinxcode{\sphinxupquote{MP\_JOIN}} option containing the \(Server_{token}\) and a random nonce, \(Client_{random}\). The server confirms the establishment of the subflow by sending a \sphinxcode{\sphinxupquote{SYN+ACK}} containing the HMAC computed using the \(Client_{random}\) and the \(Client_{secret}\) and \(Server_{secret}\) input. Thanks to this HMAC computation, the server can reveal that it knows \(Client_{secret}\) and \(Server_{secret}\) without explicitly sending them. The server also places a random number, \(Server_{random}\) in the \sphinxcode{\sphinxupquote{MP\_JOIN}} option of the \sphinxcode{\sphinxupquote{SYN+ACK}}. The client computes a HMAC and returns it in the third \sphinxcode{\sphinxupquote{ACK}}. With these two HMACs, the client and the server can authenticate the establishment of the additional subflow without revealing the shared secret.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The security of Multipath TCP depends on the security of the initial handshake

\sphinxAtStartPar
The ability of correctly authenticate the addition of new subflows to a Multipath TCP connection depends on the secrecy of the \(Client_{secret}\) and \(Server_{secret}\) exchanged in the \sphinxcode{\sphinxupquote{SYN}} and \sphinxcode{\sphinxupquote{SYN+ACK}} of the initial handshake. An on\sphinxhyphen{}path attacker which is able to capture this initial handshake has all the information required to attach a new subflow to this Multipath TCP connection at any time. Multipath does not include the strong cryptographic techniques (besides HMAC) that would have been required to completely secure the establishment the protocol and the establishment of additional subflows in particular. This threat was considered acceptable for Multipath TCP {[}\hyperlink{cite.biblio:id6032}{13}{]} because an attacker who can capture the packets of a single path TCP connection can also inject data inside this connection. To be fully secure Multipath TCP would need to rely on cryptographic techniques that are similar to those used in Transport Layer Security {[}\hyperlink{cite.biblio:id8271}{14}{]}.
\end{sphinxadmonition}

\sphinxAtStartPar
The solution described above meets the requirements of the Internet Engineering Task Force. From a security viewpoint, the \(Client_{secret}\), \(Server_{secret}\) and the random nonces should be as large as possible to prevent attacks where their values are simply guessed. Unfortunately, since Multipath TCP uses TCP options to exchange all this information, we need to ensure that it fits inside the extended header of a TCP \sphinxcode{\sphinxupquote{SYN}}. The TCP specification {[}\hyperlink{cite.biblio:id729}{2}{]} reserves up to 40 bytes to place the TCP options in a \sphinxcode{\sphinxupquote{SYN}}. Today’s TCP stacks already consume 4 bytes for the \sphinxcode{\sphinxupquote{MSS}} option {[}\hyperlink{cite.biblio:id729}{2}{]}, 3 for the \sphinxcode{\sphinxupquote{Window Scale}} option {[}\hyperlink{cite.biblio:id1255}{15}{]}, 2 for \sphinxcode{\sphinxupquote{SACK Permitted}} {[}\hyperlink{cite.biblio:id1948}{1}{]} and 10 for the timestamp option {[}\hyperlink{cite.biblio:id1255}{15}{]}. This leaves only 20 bytes to encode a Multipath TCP option that must contain an initial sequence number, a token and a secret. Multipath TCP solves this problem by deriving these three values from a single field encoded in a TCP option. Let us now analyze the Multipath TCP handshake in more details.


\subsection{The Multipath TCP handshake}
\label{\detokenize{mptcp:the-multipath-tcp-handshake}}\label{\detokenize{mptcp:mptcp-initial-mptcp-handshake}}
\sphinxAtStartPar
A Multipath TCP connection starts with a three\sphinxhyphen{}way handshake like a regular TCP connection. To indicate that it wishes to use Multipath TCP, the client adds the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option to the \sphinxcode{\sphinxupquote{SYN}} segment. In the \sphinxcode{\sphinxupquote{SYN}} segment, this option only contains some flags and occupies 4 bytes. The server replies with a \sphinxcode{\sphinxupquote{SYN+ACK}} segment than contains an \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option including a server generated 64 bits random key that will be used to authenticate connections over different paths. The client concludes the handshake by sending an \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option in the \sphinxcode{\sphinxupquote{ACK}} segment containing the random keys chosen by the client and the server.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=6; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Client};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[black,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN\small{[seq=x]}\\\small{MPC[flags]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}\\\small{MPC[flags,$Server_{key}$]}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK\small{[seq=x+1,ack=y+1]}\\\small{MPC[flags,$Client_{key}$,$Server_{key}$]}};
\end{tikzpicture}\caption{Negotiating the utilization of Multipath TCP during the three\sphinxhyphen{}way handshake}\label{\detokenize{mptcp:id63}}\label{\detokenize{mptcp:fig-tcp-handshake-mptcp}}\end{figure}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Multipath TCP version 0

\sphinxAtStartPar
The first version of Multipath TCP used a slightly different handshake {[}\hyperlink{cite.biblio:id6658}{6}{]}. The \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option sent by the client contains the 64 bits key chosen by the client. The \sphinxcode{\sphinxupquote{SYN+ACK}} segment contains an \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option with 64 bits key chosen by the server. The client echoes the client and server keys in the third \sphinxcode{\sphinxupquote{ACK}} of the handshake.
\begin{figure}[H]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=6; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Client};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[black,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN\small{[seq=x]}\\\small{MPC[flags,$Client_{key}$]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}\\\small{MPC[flags,$Server_{key}$]}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK\small{[seq=x+1,ack=y+1]}\\\small{MPC[flags,$Client_{key}$,$Server_{key}$]}};
\end{tikzpicture}\caption{Negotiating the utilization of Multipath TCP version 0}\label{\detokenize{mptcp:id64}}\label{\detokenize{mptcp:fig-tcp-handshake-mptcp-v0}}\end{figure}\end{sphinxadmonition}

\sphinxAtStartPar
The 64 bits random keys chosen by the client and the server play three different roles in Multipath TCP. Their first role is to identify the Multipath TCP connection to which an additional connection must be attached. Since a Multipath TCP connection can combine several TCP connections, Multipath TCP cannot use the IP addresses and port numbers to identify a TCP connection. Multipath TCP uses a specific identifier that is called a token. For technical reasons, this token is derived from the 64 bits key as the most significant 32 bits of the SHA\sphinxhyphen{}256 {[}\hyperlink{cite.biblio:id6083}{16}{]} hash of the key. The second role of the 64 bits keys is to authenticate the establishment of additional connections as we will see shortly. Finally, the keys are also used to compute random initial sequence numbers.

\sphinxAtStartPar
The main benefit of Multipath TCP is that a Multipath TCP connection can combine different TCP connections that potentially use different paths. Starting from now on, we will consider a client with two network interfaces and a server with one network interface. This could for example correspond to a client application running on a smartphone that interacts with a server. We explore more complex scenarios later.

\sphinxAtStartPar
We can know explain how a Multipath TCP connection can combine different TCP connections. According to the Multipath TCP specification, these connections are called subflows {[}\hyperlink{cite.biblio:id8500}{5}{]}. We also adopt this terminology in this document. \hyperref[\detokenize{mptcp:fig-mptcp-join}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-join}}} shows a Multipath TCP that combines two subflows. To establish the Multipath TCP connection, the client initiates the initial subflow by using the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option during the three\sphinxhyphen{}way handshake. At the end of the initial handshake, the client and the server have exchanged their keys. Based on their keys, they have both computed the token that the remote host uses to identify the Multipath TCP connection.

\sphinxAtStartPar
To attach a second subflow to this Multipath TCP connection, the client needs to create it. For this, it starts a three\sphinxhyphen{}way handshake with the server by sending a \sphinxcode{\sphinxupquote{SYN}} segment containing the \sphinxcode{\sphinxupquote{MP\_JOIN}} option. This option indicates that the client uses Multipath TCP and wishes to attach this new connection to an existing Multipath TCP connection. The \sphinxcode{\sphinxupquote{MP\_JOIN}} option contains two important fields:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the token that the server uses to identify the Multipath TCP connection

\item {} 
\sphinxAtStartPar
a random nonce

\end{itemize}

\sphinxAtStartPar
The client has derived the token from the key announced by the server in the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option of the \sphinxcode{\sphinxupquote{SYN+ACK}} segment on the initial subflow. Thanks to this token, the server knows to which Multipath TCP connection the new subflow needs to be attached.

\begin{sphinxadmonition}{note}{\label{\detokenize{mptcp:id24}}Todo:}
\sphinxAtStartPar
discuss security concerns
\end{sphinxadmonition}

\sphinxAtStartPar
The server uses the random nonce sent by the client and its own random nonce to prove its knowledge of the keys exchanged during the initial handshake. The server computes \(HMAC(Key=(Server_{key}||Client_{key}), Msg=(nonce_{Server}||nonce_{Client}))\), where \sphinxcode{\sphinxupquote{||}} denotes the concatenation operation. It then returns the high order 64 bits of this HMAC in the \sphinxcode{\sphinxupquote{MP\_JOIN}} option of the \sphinxcode{\sphinxupquote{SYN+ACK}} segment together with its 32 bits nonce. The client computes \(HMAC(Key=(Client_{key}||Server_{key}), Msg=(nonce_{Client}||nonce_{Server}))\) and sends the 160 bits HMAC in the \sphinxcode{\sphinxupquote{ACK}} segment.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=9; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Client};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN\small{[seq=x]}\\\small{MPC[flags]}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}\\\small{MPC[flags,$S_{key}$]}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK\small{[seq=x+1,ack=y+1]}\\\small{MPC[flags,$C_{key}$,$S_{key}$]}};
\tikzmath{\y=\max-4.5;}
\draw[red,thick, ->] (\c2,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN\small{[seq=x]}\\\small{MP\_JOIN[$S_{token}$,$nonce_{C}$]}};
\draw[red,thick, ->] (\s1,\y-1) -- (\c2,\y-2) node [midway, align=left, fill=white] {SYN+ACK\small{[seq=y,ack=x+1]}\\\small{MP\_JOIN[$HMAC_{S}$,$nonce_{S}$]}};
\draw[red,thick, ->] (\c2,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK\small{[seq=x+1,ack=y+1]}\\\small{MP\_JOIN[$HMAC_{C}$]}};
\end{tikzpicture}\caption{A client creates a second subflow by creating a TCP connection with the \sphinxcode{\sphinxupquote{MP\_JOIN}} option}\label{\detokenize{mptcp:id65}}\label{\detokenize{mptcp:fig-mptcp-join}}\end{figure}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Generating Multipath TCP keys

\sphinxAtStartPar
From a security viewpoint, the keys that Multipath TCP hosts exchange in the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} option should be completely random to prevent them from being guessed by attackers. However, since the token is derived from the key, it cannot be completely random. A host will typically generate a random key and hash it into a token to verify that it does not correspond to an existing connection. On clients, with a few tens of connections, this is not a concern, but on servers, the delay to generate random keys increases with the number of established Multipath TCP connections {[}\hyperlink{cite.biblio:id8941}{17}{]}. This does not prevent servers from supporting large numbers of Multipath TCP connections {[}\hyperlink{cite.biblio:id9001}{18}{]}.
\end{sphinxadmonition}

\sphinxAtStartPar
A Multipath TCP connection combines a number of subflows which can change during the connection lifetime. It starts with an initial subflow, but this subflow may terminate before the connection. A Multipath TCP connection is a pair of states that are maintained on the client and the server.

\sphinxAtStartPar
The above figure shows how a client adds a subflow to an existing Multipath TCP connection. This is the most common way of adding subflows to a connection. According to the specification, a server could also add subflows to a Multipath TCP connection. For this, the server needs to be able to determine the client addresses. This is the role of the address subflow management parts of Multipath TCP.


\section{Address and subflow management}
\label{\detokenize{mptcp:address-and-subflow-management}}\label{\detokenize{mptcp:mptcp-addr-management}}
\sphinxAtStartPar
Each Internet host has one address per network interface. A smartphone with active Wi\sphinxhyphen{}Fi and cellular interfaces has two network addresses. With the advent of IPv6, a large fraction of the hosts are dual\sphinxhyphen{}stack and have both an IPv4 and an IPv6 address for each network interface. Multipath TCP specifies options that allow a host to advertise all its addresses to the other host. Given the limited size of the TCP header, these options cannot be exchanged during the handshake. They are typically attached to packets that carry acknowledgments.

\sphinxAtStartPar
Each host maintains a list of its active addresses and associates a numeric identifier to each address. To advertise an address, the host simple adds the Multipath TCP \sphinxcode{\sphinxupquote{ADD\_ADDR}} option to one outgoing packet. This option contains four main fields:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the IPv4 or IPv6 address of the host

\item {} 
\sphinxAtStartPar
the numeric identifier of the address

\item {} 
\sphinxAtStartPar
an optional port number

\item {} 
\sphinxAtStartPar
a truncated HMAC to authenticate the address advertisement

\end{itemize}

\sphinxAtStartPar
The IP address is the main information contained in the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option. The identifier allows the host to advertise the list of all its addresses one option at a time. The port number allows to indicate that the hosts listens to another port number than the one used for the subflow where the option is sent. This can be useful if a client wishes to accept subflows initiated by the server or if a server uses another port to listen for additional subflows. The HMAC is the 64 bits truncation of \(HMAC(Key=(Server_{key}||Client_{key}), Msg=(Address identifier||IP address|| port))\) when the server advertises an address and \(HMAC(Key=(Client_{key}||Server_{key}), Msg=(Address identifier||IP address|| port))\) for an address advertised by the client. The HMAC allows to prevent attacks where an attacker sends spoofed packets containing an \sphinxcode{\sphinxupquote{ADD\_ADDR}} option.

\sphinxAtStartPar
In addition to these four fields, the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option contains an \sphinxcode{\sphinxupquote{Echo}} bit. The \sphinxcode{\sphinxupquote{ADD\_ADDR}} option is usually sent inside a TCP acknowledgment. A host can easily send an acknowledgment even if it did not recently receive data. Unfortunately, TCP acknowledgments are, by design, unreliable. As TCP uses cumulative acknowledgments, the loss of an acknowledgment is compensated by the next acknowledgment. This is true for the acknowledgment number, but not for the options that were contained in the loss packet. The first version of Multipath TCP did not try to deal with the loss of \sphinxcode{\sphinxupquote{ADD\_ADDR}} options. The current version relies on the \sphinxcode{\sphinxupquote{Echo}}. A host advertises an address by sending its \sphinxcode{\sphinxupquote{ADD\_ADDR}} option with the \sphinxcode{\sphinxupquote{Echo}} bit set to \sphinxcode{\sphinxupquote{0}}. To confirm the reception of this address, the peer simply replies with an acknowledgment containing the same option but with its \sphinxcode{\sphinxupquote{Echo}} bit set to one. A host that sent an \sphinxcode{\sphinxupquote{ADD\_ADDR}} option needs to retransmit it if it does not receive it back. This is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-addaddr}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-addaddr}}}.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=6; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max) {Client};
\node [black, fill=white] at (\s1,\max) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, -Circle] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {ACK\small{[ADD\_ADDR(E=0,Id=1,1.2.3.4:10)]}};
\draw[blue,thick, ->] (\c1,\y-3) -- (\s1,\y-4) node [midway, align=left, fill=white] {ACK\small{[ADD\_ADDR(E=0,Id=1,1.2.3.4:10)]}};
\draw[blue,thick, ->] (\s1,\y-4) -- (\c1,\y-5) node [midway, align=left, fill=white] {ACK\small{[ADD\_ADDR(E=1,Id=1,1.2.3.4:10)]}};
\end{tikzpicture}\caption{Thanks to the Echo bit, a Multipath TCP host can retransmit lost ADD\_ADDR options.}\label{\detokenize{mptcp:id66}}\label{\detokenize{mptcp:fig-mptcp-addaddr}}\end{figure}
\sphinxAtStartPar
Thanks to the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option, a host can advertise all its addresses at the beginning of a Multipath TCP connection. Since the option can be sent at any time, a mobile host that learns a new address, e.g. a smartphone attached to a new Wi\sphinxhyphen{}Fi network, can advertise it immediately. This makes Multipath TCP agile on mobile hosts. A host may also stop being able to use an IP address. This occurs when a mobile hosts goes away from a wireless network. In this case, the host should inform its peer about the loss of the corresponding address. This is the role of the \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} option that contains the numeric identifier of the removed address. In contrast with the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option, the \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} option is not authenticated using a truncated HMAC. The protocol specification suggests that when a host receives a \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} option, it should first check whether it is currently used by an active subflow. If no, the address can be removed. If yes, it should send a TCP Keepalive on this subflow to verify whether the address still works. If it does not receive a response to its keepalive, the address can be removed and the associated subflow is reset. Otherwise, the \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} option is ignored.

\sphinxAtStartPar
Multipath TCP hosts use the \sphinxcode{\sphinxupquote{ADD\_ADDR}} and \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} options to maintain the list of addresses used by their peer. However, this is not the only source of information that Multipath TCP uses. A Multipath TCP hosts also learns the source addresses of the established subflows. The first addresses are those used for the initial subflow. The client remembers the server’s address as address \sphinxcode{\sphinxupquote{0}} on this Multipath TCP connection. The server does the same with the client address. When the client creates a new subflow, it places the numeric identifier of the source address of this subflow in the \sphinxcode{\sphinxupquote{MP\_JOIN}} option. This enables the server to learn additional addresses and their associated numeric identifiers. This is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-addr-management}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-addr-management}}}. The server first learns that the client is reachable via the address used for the initial subflow (\(IP_{A}\)). The identifier of this address is \(0\). Then, the server learns that the client is also reachable through IP address \(IP_{B}\). Thanks to the identifier contained in the \sphinxcode{\sphinxupquote{MP\_JOIN}} option, the server also learns the identifier (\(2\)) of this address. Then, the server learns the third address (\$IP\_\{C\}\$) using the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=12; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max+0.5) {Client};
\node [black, fill=white] at (\s1,\max+0.5) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\node [blue, fill=white] at (\c1-0.5,\max) {$IP_{A}$};
\node [red, fill=white] at (\c2,\max) {$IP_{B}$};
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN \small{MPC}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK \small{MPC}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK \small{MPC}};
\node [black,fill=white,align=left] at (\s1+1,\y-3.7) {Client addrs: $0:IP_{A}$};
\tikzmath{\y=\max-4.5;}
\draw[red,thick, ->] (\c2,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN \small{MP\_JOIN[id=2]}};
\draw[red,thick, ->] (\s1,\y-1) -- (\c2,\y-2) node [midway, align=left, fill=white] {SYN+ACK \small{MP\_JOIN}};
\draw[red,thick, ->] (\c2,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK \small{MP\_JOIN}};
\node [black,fill=white,align=left] at (\s1+1,\y-3.7) {Client addrs: $0:IP_{A}$,$2:IP_{B}$};
\draw[blue,thick, ->] (\c1,\y-4) -- (\s1,\y-5) node [midway, align=left, fill=white] {ACK \small{ADD\_ADDR[id=1,$IP_{C}$]}};
\node [black,fill=white] at (\s1+1,\y-5.7) {Client addrs: $0:IP_{A}$,$1:IP_{C}$,$2:IP_{B}$};
\end{tikzpicture}\caption{A Multipath TCP hosts remembers the addresses used by its peer}\label{\detokenize{mptcp:id67}}\label{\detokenize{mptcp:fig-mptcp-addr-management}}\end{figure}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Is the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option required on all Multipath TCP hosts ?

\sphinxAtStartPar
The previous section has explained how Multipath TCP hosts learn the addresses of their peers by using the \sphinxcode{\sphinxupquote{ADD\_ADDR}} and \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} options. These options are important for a server that has multiple addresses (e.g. an IPv4 and an IPv6 address) and wants to advertise them to its clients. On the other hand, servers rarely create subflows and thus they do not really need to learn the client addresses. In fact, Apple’s implementation of Multipath TCP on the iPhones does not use the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option. iPhones simply create subflows over the cellular and Wi\sphinxhyphen{}Fi interfaces as when needed and the server relies on the \sphinxcode{\sphinxupquote{MP\_JOIN}} option to validate these subflows. It is interesting to note that the \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} option remains useful even if the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option is not used. Consider a smartphone that has created an initial subflow over its Wi\sphinxhyphen{}Fi interface and a second subflow over the cellular one. If the smartphone looses its Wi\sphinxhyphen{}Fi interface, it can send a \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} option over the subflow that uses the cellular interface to inform the server that it cannot be reached anymore through its Wi\sphinxhyphen{}Fi interface.
\end{sphinxadmonition}


\section{Data transfer}
\label{\detokenize{mptcp:data-transfer}}\label{\detokenize{mptcp:mptcp-data-transfer}}
\sphinxAtStartPar
Thanks to the \sphinxcode{\sphinxupquote{MP\_CAPABLE}} and \sphinxcode{\sphinxupquote{MP\_JOIN}} option, Multipath TCP hosts can associate one of more subflows to a Multipath TCP connection. Each host can send and receive data on any of the established subflows. As these subflows follow different paths, packets experience different delays. To preserve the in\sphinxhyphen{}order bytestream, the receiver must be able to reorder the data received over the different subflows.

\sphinxAtStartPar
A simple approach to perform this reordering would be to rely on the TCP sequence number that is included in the TCP header. This approach is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-dss-naive}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-dss-naive}}}. The client creates two subflows and uses the same initial sequence numbers on the different subflows. The server also selects the same initial sequence numbers. The client then sends three bytes: \sphinxcode{\sphinxupquote{A}} over the initial subflow, \sphinxcode{\sphinxupquote{B}} over the second subflow and \sphinxcode{\sphinxupquote{C}} over the initial one. Each byte has its own sequence number and the receiver can reorder them. However, note that sequence number \sphinxcode{\sphinxupquote{x+2}} is not sent over the initial subflow. Furthermore, sequence numbers \sphinxcode{\sphinxupquote{x+1}} and \sphinxcode{\sphinxupquote{x+3}} are not sent over the second subflow.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=12; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max+0.5) {Client};
\node [black, fill=white] at (\s1,\max+0.5) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN[seq=x] \small{MPC}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK[seq=y,ack=x+1] \small{MPC}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK[ack=y+1] \small{MPC}};
\tikzmath{\y=\max-4.5;}
\draw[red,thick, ->] (\c2,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN[seq=x] \small{MP\_JOIN[id=2]}};
\draw[red,thick, ->] (\s1,\y-1) -- (\c2,\y-2) node [midway, align=left, fill=white] {SYN+ACK[seq=y,ack=x+1] \small{MP\_JOIN}};
\draw[red,thick, ->] (\c2,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK[ack=y+1] \small{MP\_JOIN}};
\draw[blue,thick, ->] (\c1,\y-4) -- (\s1,\y-5) node [midway, align=left, fill=white] {[seq=x+1] "A"};
\draw[red,thick, ->] (\c2,\y-4.5) -- (\s1,\y-5.5) node [midway, align=left, fill=white] {[seq=x+2] "B"};
\draw[blue,thick, ->] (\c1,\y-5) -- (\s1,\y-6) node [midway, align=left, fill=white] {[seq=x+3] "C"};
\end{tikzpicture}\caption{A naive approach to exchange data over different subflows}\label{\detokenize{mptcp:id68}}\label{\detokenize{mptcp:fig-mptcp-dss-naive}}\end{figure}
\sphinxAtStartPar
Unfortunately, this simple approach suffers from several problems. First, it assumes that the client and the server use the same initial sequence numbers. On the client side, this might be feasible, but on the server side, this would prohibit the utilization of techniques such as SYN cookies that are important to protect from denial of service attacks. Another concern is that there will be gaps in the sequence numbers that are used over each path. These gaps might cause problems with middleboxes such as firewalls. The same problem applies for the acknowledgments. Although TCP supports selective acknowledgments \index{RFC@\spxentry{RFC}!RFC 2018@\spxentry{RFC 2018}}\sphinxhref{https://tools.ietf.org/html/rfc2018.html}{\sphinxstylestrong{RFC 2018}}, these were not designed to support a large number of gaps.

\sphinxAtStartPar
Multipath TCP solves these problems by using a second level of sequence numbers that are encoded inside TCP options. Conceptually, Multipath TCP associates a data sequence number to the first byte of the payload of each TCP packet. Each Multipath TCP packet carries two different sequence numbers. The first is the sequence number that is included in the TCP header and is called the subflow sequence number. This sequence number plays the same role as in a regular TCP connection. It enables the receiver to reorder the received packets on a given subflow and detect losses. The data sequence number corresponds to the bytestream. It indicates the position of the first byte of the payload of the TCP packet in the bytestream. This data sequence number is used by the receiver to reorder the data received over different subflows and detect losses at this level. Multipath TCP also uses acknowledgments to confirm the reception of data. At the subflow level these are regular TCP acknowledgments (or selective acknowledgments if this extension is active). At the Multipath TCP connection level, the receiver always returns a data acknowledgment that contains the next expected in\sphinxhyphen{}sequence data sequence number. This is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-dss-concept}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-dss-concept}}}.

\sphinxAtStartPar
The client sends the first byte of the bytestream over the initial subflow. This byte is sent in a TCP packet whose sequence number is \sphinxcode{\sphinxupquote{x+1}}. It carries a Multipath TCP option that contains the data sequence number, i.e. \sphinxcode{\sphinxupquote{0}} since this is the first byte of the bytestream. The server returns an acknowledgment that indicates that the \sphinxcode{\sphinxupquote{x+2}} is the next expected sequence number over the initial subflow. This TCP ACK also contains a Multipath TCP option that indicates that \sphinxcode{\sphinxupquote{1}} is the next expected data sequence number. The sends the second byte over the second subflow. For this, it sends a packet whose sequence number is set to \sphinxcode{\sphinxupquote{w+1}}, i.e. the first sequence number over this subflow. This packet contains a Multipath TCP option that indicates that this is the second byte (data sequence set to \sphinxcode{\sphinxupquote{1}}) of the bytestream. The server confirms the reception of this packet with an acknowledgment.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=17; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max+0.5) {Client};
\node [black, fill=white] at (\s1,\max+0.5) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, ->] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN[seq=x] \small{MPC}};
\draw[blue,thick, ->] (\s1,\y-1) -- (\c1,\y-2) node [midway, align=left, fill=white] {SYN+ACK[seq=y,ack=x+1] \small{MPC}};
\draw[blue,thick, ->] (\c1,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK[ack=y+1] \small{MPC}};
\tikzmath{\y=\max-4.5;}
\draw[red,thick, ->] (\c2,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {SYN[seq=w] \small{MP\_JOIN[id=2]}};
\draw[red,thick, ->] (\s1,\y-1) -- (\c2,\y-2) node [midway, align=left, fill=white] {SYN+ACK[seq=z,ack=w+1] \small{MP\_JOIN}};
\draw[red,thick, ->] (\c2,\y-2.1) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK[ack=z+1] \small{MP\_JOIN}};
\draw[blue,thick, ->] (\c1,\y-4) -- (\s1,\y-5) node [midway, align=left, fill=white] {[seq=x+1]\small{DS[s=0]} "A"};
\draw[blue,thick, ->] (\s1,\y-5) -- (\c1,\y-6) node [midway, align=left, fill=white] {ACK [ack=x+2]\small{DS[a=1]}};
\draw[red,thick, ->] (\c2,\y-6) -- (\s1,\y-7) node [midway, align=left, fill=white] {[seq=w+1]\small{DS[s=1]} "B"};
   \draw[red,thick, ->] (\s1,\y-7) -- (\c2,\y-8) node [midway, align=left, fill=white] {ACK [ack=w+2]\small{DS[a=2]}};
\draw[blue,thick, ->] (\c1,\y-8.5) -- (\s1,\y-9.5) node [midway, align=left, fill=white] {[seq=x+2]\small{DS[s=2]} "C"};
\draw[blue,thick, ->] (\s1,\y-9.5) -- (\c1,\y-10.5) node [midway, align=left, fill=white] {ACK [ack=x+2]\small{DS[a=3]}};
\end{tikzpicture}\caption{Multipath TCP relies on data sequence numbers and acknowledgments}\label{\detokenize{mptcp:id69}}\label{\detokenize{mptcp:fig-mptcp-dss-concept}}\end{figure}
\sphinxAtStartPar
\hyperref[\detokenize{mptcp:fig-mptcp-dss-concept2}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-dss-concept2}}} shows a slightly different example where the first data packet sent by the client is lost. When the server receives the second byte of the bytestream on the second subflow, it acknowledges it at the subflow level (\sphinxcode{\sphinxupquote{ack=w+2}}) but not at the connection level since the previous byte of the bytestream is missing. The server stores the received byte in the reordering buffer associated with the connection. When the server receives the second packet sent over the initial subflow, it stores it in the buffer associated with the initial subflow. Since it has neither received the byte that has sequence number \sphinxcode{\sphinxupquote{x+1}} on the initial subflow, it cannot update its acknowledgment number. It could send a selective acknowledgment if these were enabled on the connection. The retransmission of the first data packet sent over the initial subflow fills the buffer associated to this subflow. The server can thus update the subflow level acknowledgment number (\sphinxcode{\sphinxupquote{ack=x+2}}). The data received in order can now be passed to the connection\sphinxhyphen{}level buffer. The data at this level is also in\sphinxhyphen{}sequence and the server returns a data acknowledgment indicating that the next data sequence number it expects is \sphinxcode{\sphinxupquote{3}}. The three bytes \sphinxcode{\sphinxupquote{ABC}} are delivered in sequence to the server application.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=9; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max+0.5) {Client};
\node [black, fill=white] at (\s1,\max+0.5) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, -Circle] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {[seq=x+1]\small{DS[s=0]} "A"};
\draw[red,thick, ->] (\c2,\y-2) -- (\s1,\y-3) node [midway, align=left, fill=white] {[seq=w+1]\small{DS[s=1]} "B"};
   \draw[red,thick, ->] (\s1,\y-3) -- (\c2,\y-4) node [midway, align=left, fill=white] {ACK [ack=w+2]\small{DS[a=0]}};
\draw[blue,thick, ->] (\c1,\y-4) -- (\s1,\y-5) node [midway, align=left, fill=white] {[seq=x+2]\small{DS[s=2]} "C"};
\draw[blue,thick, ->] (\s1,\y-5) -- (\c1,\y-6) node [midway, align=left, fill=white] {ACK [ack=x+1]\small{DS[a=0]}};
\draw[blue,thick, ->] (\c1,\y-6) -- (\s1,\y-7) node [midway, align=left, fill=white] {[seq=x+1]\small{DS[s=0]} "A"};
\draw[blue,thick, ->] (\s1,\y-7) -- (\c1,\y-8) node [midway, align=left, fill=white] {ACK [ack=x+2]\small{DS[a=3]}};
\end{tikzpicture}\caption{Multipath TCP copes with packet losses}\label{\detokenize{mptcp:id70}}\label{\detokenize{mptcp:fig-mptcp-dss-concept2}}\end{figure}
\sphinxAtStartPar
The example of \hyperref[\detokenize{mptcp:fig-mptcp-dss-concept2}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-dss-concept2}}} showed how Multipath TCP copes with packet losses. These are frequent events on a TCP connection. A Multipath TCP only needs to cope with the loss of an entire subflow. Consider the same example as above, but the initial subflow was established over a Wi\sphinxhyphen{}Fi interface that stops shortly after the reception of the acknowledgment for the second data packet. The client detects the problem and sends a \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} over the second subflow. It also retransmits the first packet that had not been acknowledged, but this time over the second subflow.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=11; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max+0.5) {Client};
\node [black, fill=white] at (\s1,\max+0.5) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,thick, -Circle] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {[seq=x+1]\small{DS[s=0]} "A"};
\draw[red,thick, ->] (\c2,\y-2) -- (\s1,\y-3) node [midway, align=left, fill=white] {[seq=w+1]\small{DS[s=1]} "B"};
\draw[red,thick, ->] (\s1,\y-3) -- (\c2,\y-4) node [midway, align=left, fill=white] {ACK [ack=w+2]\small{DS[a=0]}};
\draw[blue,thick, ->] (\c1,\y-4) -- (\s1,\y-5) node [midway, align=left, fill=white] {[seq=x+2]\small{DS[s=2]} "C"};
\draw[blue,thick, ->] (\s1,\y-5) -- (\c1,\y-6) node [midway, align=left, fill=white] {ACK [ack=x+1]\small{DS[a=0]}};
\draw[red,thick, ->] (\c2,\y-6.5) -- (\s1,\y-7.5) node [midway, align=left, fill=white] {\small{REMODE\_ADDR[id=0]}};
\draw[red,thick, ->] (\c2,\y-7) -- (\s1,\y-8) node [midway, align=left, fill=white] {[seq=w+2]\small{DS[s=0]} "A"};
\draw[red,thick, ->] (\s1,\y-8) -- (\c2,\y-9) node [midway, align=left, fill=white] {ACK [ack=w+3]\small{DS[a=3]}};
\end{tikzpicture}\caption{Multipath TCP copes with subflow failures}\label{\detokenize{mptcp:id71}}\label{\detokenize{mptcp:fig-mptcp-dss-concept3}}\end{figure}
\sphinxAtStartPar
Conceptually, a Multipath TCP implementation can be viewed as composed of a set of queues. On the sender side, the bytestream is pushed in a queue that keeps the data until it has been acknowledged at the connection level. A packet scheduler extracts blocks of data from this queue and places them with the associated date sequence numbers in the per\sphinxhyphen{}subflow queues that represent the sending buffers associated to each subflow. TCP uses these per\sphinxhyphen{}subflow queues to send the data and perform the retransmission when required. On the receiver side, there is one queue associated with each subflow. This queue corresponds to the TCP receive buffer. TCP uses this queue to reorder the received data based on their TCP sequence numbers, but does not deal with the data sequence numbers that are contained in TCP options. Once data is in\sphinxhyphen{}order in a subflow receive buffer, it goes in the connection\sphinxhyphen{}level reorder queue that uses the data sequence numbers contained in TCP options to recover the bytestream. Multipath TCP creates the data sequence acknowledgments from the data contained in this buffer. Once data is in\sphinxhyphen{}sequence inside this buffer, it is passed to the application through a \sphinxcode{\sphinxupquote{recv}} system call.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
figure from slide
};
\end{tikzpicture}\caption{Architecture of a Multipath TCP implementation}\label{\detokenize{mptcp:id72}}\end{figure}

\section{Congestion control}
\label{\detokenize{mptcp:congestion-control}}\label{\detokenize{mptcp:mptcp-congestion}}
\begin{sphinxadmonition}{note}{\label{\detokenize{mptcp:id27}}Todo:}
\sphinxAtStartPar
explain basic idea and the problem of having
\end{sphinxadmonition}


\subsection{LIA}
\label{\detokenize{mptcp:lia}}
\sphinxAtStartPar
{[}\hyperlink{cite.biblio:id8932}{19}{]} and {[}\hyperlink{cite.biblio:id6203}{20}{]}


\subsection{OLIA}
\label{\detokenize{mptcp:olia}}
\sphinxAtStartPar
{[}\hyperlink{cite.biblio:id8951}{21}{]}


\subsection{BALIA}
\label{\detokenize{mptcp:balia}}
\sphinxAtStartPar
{[}\hyperlink{cite.biblio:id8993}{22}{]}


\subsection{MPCC}
\label{\detokenize{mptcp:mpcc}}
\sphinxAtStartPar
{[}\hyperlink{cite.biblio:id9002}{23}{]}


\section{Connection release}
\label{\detokenize{mptcp:connection-release}}\label{\detokenize{mptcp:mptcp-release}}
\begin{sphinxadmonition}{note}{\label{\detokenize{mptcp:id33}}Todo:}
\sphinxAtStartPar
keepalive and end of a connection
\end{sphinxadmonition}

\sphinxAtStartPar
A TCP connection starts with a three\sphinxhyphen{}way handshake and ends with either the exchange of \sphinxcode{\sphinxupquote{FIN}} packets to gracefully terminate the connection or when one of the hosts sends a \sphinxcode{\sphinxupquote{RST}} packet. The main benefit of the graceful termination is that both hosts receive the confirmation that all the data that they have sent over the connection has been correctly received. Multipath also supports a graceful termination of the connection. As in regular TCP, this graceful termination is implemented by using a flag that indicates the end of the bytestream. This flag is included in the Data Sequence Number option.

\sphinxAtStartPar
\hyperref[\detokenize{mptcp:fig-mptcp-close}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-close}}} illustrates a graceful Multipath TCP connection release. We assume that the connection has two active subflows. The client sends \sphinxcode{\sphinxupquote{XYZ}} over the initial subflow. Since this is the last byte sent over the bytestream, it adds the \sphinxcode{\sphinxupquote{DATA\_FIN}} flag to the data sequence option. This flag consumes one data sequence number as the \sphinxcode{\sphinxupquote{FIN}} flag in the TCP header. The server returns an acknowledgment that confirms the reception of the three bytes at the subflow level (\sphinxcode{\sphinxupquote{ack=x+3}}). At the connection level, four sequence numbers are acknowledged (\sphinxcode{\sphinxupquote{a=y+4}}) since the \sphinxcode{\sphinxupquote{DATA\_FIN}} flag consumes one sequence number. The server decides to close its bytestream by sending its last byte, \sphinxcode{\sphinxupquote{M}}, over the second subflow with the \sphinxcode{\sphinxupquote{DATA\_FIN}} flag set. At this point, the Multipath TCP has been gracefully closed. No data will be exchanged over the different subflows. The client and/or the server can terminate the subflows by using packets with either the \sphinxcode{\sphinxupquote{FIN}} or the \sphinxcode{\sphinxupquote{RST}} flag in the TCP header.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=8; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max+0.5) {Client};
\node [black, fill=white] at (\s1,\max+0.5) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,dashed,<->] (\c1,\y) -- (\s1,\y) node [midway, fill=white] {Initial subflow};
\draw[red,dashed,<->] (\c2,\y-0.5) -- (\s1,\y-0.5) node [midway, fill=white] {Second subflow};
\draw[blue,thick, ->] (\c1,\y-2) -- (\s1,\y-3) node [midway, align=left, fill=white] {[seq=x]\small{DS[s=y,DATA\_FIN]} "XYZ"};
\draw[blue,thick, ->] (\s1,\y-3) -- (\c1,\y-4) node [midway, align=left, fill=white] {ACK [ack=x+3]\small{DS[a=y+4]}};
\draw[red,thick, ->] (\s1,\y-4.5) -- (\c2,\y-5.5) node [midway, align=left, fill=white] {[seq=w]\small{DS[s=z,DATA\_FIN]} "M"};
\draw[red,thick, ->] (\c2,\y-5.5) -- (\s1,\y-6.5) node [midway, align=left, fill=white] {ACK [ack=w+1]\small{DS[a=z+2]}};
\end{tikzpicture}\caption{Graceful termination of a Multipath TCP connection}\label{\detokenize{mptcp:id73}}\label{\detokenize{mptcp:fig-mptcp-close}}\end{figure}
\sphinxAtStartPar
The main drawback of exchanging \sphinxcode{\sphinxupquote{DATA\_FINs}} to terminate a Multipath TCP is that this takes time. Busy servers might not be willing to spend a long time waiting for the exchange of all these packets if the application already guarantees the correct delivery of the data. A regular TCP server would send a \sphinxcode{\sphinxupquote{RST}} packet to quickly terminate such a connection. However, such \sphinxcode{\sphinxupquote{RST}} packets can lead to denial of service attacks {[}\hyperlink{cite.biblio:id5818}{24}{]}. A regular TCP receiver mitigates these attacks by checking the sequence number of the \sphinxcode{\sphinxupquote{RST}} packet {[}\hyperlink{cite.biblio:id5558}{25}{]}. The Multipath TCP designers did not consider this approach to be safe since an attacker who is able to observe the packets on one path could send a \sphinxcode{\sphinxupquote{RST}} packet that would terminate all the subflows used by the connection.

\sphinxAtStartPar
To still allow a host to quickly terminate a Multipath TCP connection, Multipath TCP must be able to verify the validity of a packet that terminates a connection. For this, Multipath TCP defines the \sphinxcode{\sphinxupquote{FAST\_CLOSE}} option that includes a 64 bits security key. These keys are exchanged during the initial handshake and included in the state associated to a Multipath TCP connection. To quickly close a connection, a host simply needs to send the key of the remote host in a \sphinxcode{\sphinxupquote{FAST\_CLOSE}} option sent over one of the active subflows. The Multipath TCP specification defines two different methods to use the \sphinxcode{\sphinxupquote{FAST\_CLOSE}} option.

\sphinxAtStartPar
The first solution is to send the \sphinxcode{\sphinxupquote{FAST\_CLOSE}} option inside an \sphinxcode{\sphinxupquote{ACK}}. Upon reception of such a packet, a host sends a \sphinxcode{\sphinxupquote{RST}} over all active subflows. This is illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-fastclose-a}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-fastclose-a}}}.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=6; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max+0.5) {Client};
\node [black, fill=white] at (\s1,\max+0.5) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,dashed,<->] (\c1,\y) -- (\s1,\y) node [midway, fill=white] {Initial subflow};
\draw[red,dashed,<->] (\c2,\y-0.5) -- (\s1,\y-0.5) node [midway, fill=white] {Second subflow};
\draw[blue,thick, ->] (\c1,\y-2) -- (\s1,\y-3) node [midway, align=left, fill=white] {ACK,FAST\_CLOSE[$Server_{key}$] };
\draw[blue,thick, ->] (\s1,\y-3) -- (\c1,\y-4) node [midway, align=left, fill=white] {RST};
\draw[red,thick, ->] (\s1,\y-3.5) -- (\c2,\y-4.5) node [midway, align=left, fill=white] {RST};
\end{tikzpicture}\caption{Abrupt release of a Multipath TCP connection by sending FAST\_CLOSE inside an ACK}\label{\detokenize{mptcp:id74}}\label{\detokenize{mptcp:fig-mptcp-fastclose-a}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=6; }
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max+0.5) {Client};
\node [black, fill=white] at (\s1,\max+0.5) {Server};
\draw[blue,very thick,->] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,->] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,->] (\c2,\max-0.5) -- (\c2,0.5);
\tikzmath{\y=\max-1;}
\draw[blue,dashed,<->] (\c1,\y) -- (\s1,\y) node [midway, fill=white] {Initial subflow};
\draw[red,dashed,<->] (\c2,\y-0.5) -- (\s1,\y-0.5) node [midway, fill=white] {Second subflow};
\draw[blue,thick, ->] (\c1,\y-2) -- (\s1,\y-3) node [midway, align=left, fill=white] {RST,FAST\_CLOSE[$Server_{key}$]};
\draw[red,thick, ->] (\c2,\y-2.5) -- (\s1,\y-3.5) node [midway, align=left, fill=white] {RST, FAST\_CLOSE[$Server_{key}$]};
\end{tikzpicture}\caption{Abrupt release of a Multipath TCP connection by sending a RST with FAST\_CLOSE on all subflows}\label{\detokenize{mptcp:id75}}\label{\detokenize{mptcp:fig-mptcp-fastclose-b}}\end{figure}

\section{Coping with middlebox interference}
\label{\detokenize{mptcp:coping-with-middlebox-interference}}\label{\detokenize{mptcp:mptcp-middlebox}}
\sphinxAtStartPar
The previous sections have explained how Multipath TCP operates at a high level. They assume a simple network that is mainly composed of hosts, switches and routers. TCP and Multipath TCP are used by the hosts. They rely on IP packets that contain the TCP segments. These packets are forwarded by IP routers and possibly switches at layer\sphinxhyphen{}2 before reaching their final destination. In a network that uses layered protocols, the switches only inspect the layer\sphinxhyphen{}2 headers, the routers only read and change the layer\sphinxhyphen{}2 and layer\sphinxhyphen{}3 headers. Neither the switches nor the routers read or modify the payload of the packets that they forward. Unfortunately, this assumption is not true on the global Internet and in enterprise networks. Besides switches and routers, these networks contains other types of equipment that process packets {[}\hyperlink{cite.biblio:id8916}{26}{]}. These devices are usually called middleboxes because they reside in the middle of the network and process packets in different ways. A detailed survey of all the different types of middleboxes is outside the scope of this document. We discuss below some of the popular middleboxes and analyze how they have influenced the design of Multipath TCP.

\sphinxAtStartPar
Our first middlebox is a firewall. A firewall is a device that receives packets, analyzes their contents and then forwards or blocks the packet. The simplest firewalls are the stateless firewalls that accept or reject each individual packet. Such a firewall can accept packet based on the source or destination addresses or port numbers. Some firewalls also check the flags or the IP header or reassemble the received packet fragments. Others analyze the TCP header and verify the utilization of the TCP options. A firewall can be configured using a white list or a black list. A white list specifies all the packet fields that are valid and all the others are invalid. On the other hand, a black list specifies the packets that must be rejected by the firewall and all the others are accepted. Many firewalls use a small white list that defines the TCP options that the firewall accepts. This list typically includes the widely deployed options such as MSS {[}\hyperlink{cite.biblio:id729}{2}{]}, timestamps {[}\hyperlink{cite.biblio:id7140}{27}{]}, windows scale {[}\hyperlink{cite.biblio:id1245}{28}{]} and selective acknowledgments {[}\hyperlink{cite.biblio:id1948}{1}{]}. TCP options are encoded using the Kind, Length, Value format shown in \hyperref[\detokenize{mptcp:fig-mptcp-tcp-option}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-tcp-option}}}.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0) {
\begin{bytefield}{32}
\bitbox{8}{Kind} & \bitbox{8}{Length} & \bitbox{16}{Value ...}
\end{bytefield}
};
\end{tikzpicture}\caption{Generic format for TCP options}\label{\detokenize{mptcp:id76}}\label{\detokenize{mptcp:fig-mptcp-tcp-option}}\end{figure}
\sphinxAtStartPar
It is interesting to explore how such a firewall reacts when it receives a packet containing a TCP option that is not part of its whitelist. There are two possibilities. Some firewalls simply drop the packet, but this blocks a connection that could be totally legitimate. Other firewalls remove the option from the TCP header. This can be done by either removing the bytes that contain the unknown TCP option, adjust the Length field of the IP header, the TCP Header length (and possibly update the padding) and update the TCP checksum. A simpler approach is to replace the bytes of the option with byte \sphinxcode{\sphinxupquote{1}}. This corresponds to the standard No\sphinxhyphen{}Operation TCP option {[}\hyperlink{cite.biblio:id729}{2}{]}. The advantage of this approach is that the firewall only has to recompute the TCP checksum and does not need to adjust the packet length and move data.

\sphinxAtStartPar
The removal of TCP options by firewalls has influenced the design of Multipath TCP. Multipath TCP uses TCP options to exchange different types of information. The information carried in a \sphinxcode{\sphinxupquote{SYN}} is not the same as the one exchanged in data packets. The selective acknowledgments TCP extension {[}\hyperlink{cite.biblio:id1948}{1}{]} defines two different options: a two bytes long \sphinxcode{\sphinxupquote{SACK permitted}} that is used inside \sphinxcode{\sphinxupquote{SYN}} and a variable length \sphinxcode{\sphinxupquote{SACK}} option that carries the selective acknowledgments during the data transfer. The first versions of Multipath TCP used a similar approach with different TCP options kinds. However, the Multipath TCP designers feared that some firewalls could accept some of the Multipath TCP options and drop the others. For example, the Multipath TCP option used in the \sphinxcode{\sphinxupquote{SYN}} could pass a firewall that would later drop the options used in data packets. It would have been very difficult for a Multipath TCP implementation to deal with all the corner cases that could happen since Multipath TCP {[}\hyperlink{cite.biblio:id8500}{5}{]} currently defines 9 different options. To prevent such problems, Multipath TCP uses a single TCP option kind and each Multipath TCP option contains a subtype field. This increases the length of the Multipath TCP options, but minimizes the risk of middlebox interference.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind} & \bitbox{8}{Length} & \bitbox{4}{\tiny{Subtype}} & \bitbox[ltr]{12}{}\\
\bitbox[blr]{32}{Sub-type specific data}
\end{bytefield}
};
\end{tikzpicture}\caption{The generic format for Multipath TCP options}\label{\detokenize{mptcp:id77}}\label{\detokenize{mptcp:fig-mptcp-tcp-option2}}\end{figure}
\sphinxAtStartPar
Before looking at other middleboxes, it is interesting to analyze how a router forwards an IP packet that contains a TCP segment. Consider a router that receives a packet such as the one shown in \hyperref[\detokenize{mptcp:fig-mptcp-ip4tcp}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-ip4tcp}}}. When a router forwards such a packet, it will read the IP header and may modify the fields highlighted in red:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the Differentiated Services Codepoint (DSCP)

\item {} 
\sphinxAtStartPar
the Explicit Congestion Notification flags (the CE bit)

\item {} 
\sphinxAtStartPar
decrement the Time to Live

\item {} 
\sphinxAtStartPar
update the IP header checksum

\end{itemize}

\sphinxAtStartPar
A router will never change any other field of the IP header and will not read the packet payload.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\definecolor{lightred}{rgb}{1,0.7,0.71}
\begin{bytefield}{32}
\bitheader{0-31} \\
\bitbox{4}{Ver} &  \bitbox{4}{IHL} & \bitbox{6}[bgcolor=lightred]{DSCP} & \bitbox{2}[bgcolor=lightred]{\tiny ECN} & \bitbox{16}{Length}  \\
\bitbox{16}{Identification} & \bitbox{3}{\tiny Flags} & \bitbox{13}{Offset} \\
\bitbox{8}[bgcolor=lightred]{TTL} & \bitbox{8}{Protocol} & \bitbox{16}[bgcolor=lightred]{IP Checksum} \\
\bitbox{32}{Source Address} \\
\bitbox{32}{Destination Address} \\
\bitbox{16}{Source Port} &  \bitbox{16}{Destination Port} \\
\bitbox{32}{Sequence number} \\
\bitbox{32}{Acknowledgment number } \\
\bitbox{4}{Offset} & \bitbox{6}{Res} & \bitbox{1}{\tiny U\\R\\G} & \bitbox{1}{\tiny A\\C\\K} & \bitbox{1}{\tiny P\\S\\H} & \bitbox{1}{\tiny R\\S\\T} & \bitbox{1}{\tiny S\\Y\\N} & \bitbox{1}{\tiny F\\I\\N} & \bitbox{16}{Window} \\
\bitbox{16}{TCP Checksum} &  \bitbox{16}{Urgent Pointer} \\
\end{bytefield}
};
\end{tikzpicture}\caption{Fields of an IPv4 packet carrying a TCP segment which can be modified by a router}\label{\detokenize{mptcp:id78}}\label{\detokenize{mptcp:fig-mptcp-ip4tcp}}\end{figure}
\sphinxAtStartPar
Today, most TCP stacks set the Don’t Fragment flag when sending TCP packets. This implies that IPv4 routers will not fragment the packet. Even if a router fragments an IPv4 packet, this is transparent for the TCP stack since the IP stack on the receiver will reassemble the packet before passing its contents to TCP.

\sphinxAtStartPar
Unfortunately, deployed networks also contain Network Address Translators (NAT) {[}\hyperlink{cite.biblio:id2952}{29}{]}. We consider three different types of NATs because they interfere in different ways with TCP extensions such as Multipath TCP. A NAT is usually located at the boundary between a private network and the Internet. The hosts of the private network use private IP addresses {[}\hyperlink{cite.biblio:id1848}{30}{]} and the NAT is configured with a pool of public addresses. When the NAT receives an IP packet from a host in the private network, its maps the source IP address to a public one and rewrites the packet before forwarding it to the public Internet. When the NAT receives a packet from the Internet, it checks if there is a mapping for the packet’s destination address. If so, the destination address is translated and the packet is forwarded to the private host.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\definecolor{lightred}{rgb}{1,0.7,0.71}
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{4}{Ver} &  \bitbox{4}{IHL} & \bitbox{6}[bgcolor=lightred]{DSCP} & \bitbox{2}[bgcolor=lightred]{\tiny ECN} & \bitbox{16}{Length}  \\
\bitbox{16}{Identification} & \bitbox{3}{\tiny Flags} & \bitbox{13}{Offset} \\
\bitbox{8}[bgcolor=lightred]{TTL} & \bitbox{8}{Protocol} & \bitbox{16}[bgcolor=lightred]{IP Checksum} \\
\bitbox{32}[bgcolor=lightred]{Source Address} \\
\bitbox{32}[bgcolor=lightred]{Destination Address} \\
\bitbox{16}{Source Port} &  \bitbox{16}{Destination Port} \\
\bitbox{32}{Sequence number} \\
\bitbox{32}{Acknowledgment number } \\
\bitbox{4}{Offset} & \bitbox{6}{Res} & \bitbox{1}{\tiny U\\R\\G} & \bitbox{1}{\tiny A\\C\\K} & \bitbox{1}{\tiny P\\S\\H} & \bitbox{1}{\tiny R\\S\\T} & \bitbox{1}{\tiny S\\Y\\N} & \bitbox{1}{\tiny F\\I\\N} & \bitbox{16}{Window} \\
\bitbox{16}[bgcolor=lightred]{TCP Checksum} &  \bitbox{16}{Urgent Pointer} \\
\end{bytefield}
};
\end{tikzpicture}\caption{Fields of an IPv4 packet carrying a TCP segment which can be modified by a simple NAT}\label{\detokenize{mptcp:id79}}\label{\detokenize{mptcp:fig-mptcp-ip4tcp-nat}}\end{figure}
\sphinxAtStartPar
As illustrated in \hyperref[\detokenize{mptcp:fig-mptcp-ip4tcp-nat}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-ip4tcp-nat}}}, this NAT updates the source or destination address of the packet depending on the packet direction. This modification forces the NAT to recompute the IP checksum but also the TCP checksum since it covers the TCP packet and a pseudo header that includes the IP addresses {[}\hyperlink{cite.biblio:id729}{2}{]}. In practice, these two checksums are incrementally updated {[}\hyperlink{cite.biblio:id2952}{29}{]} and do not need to be recomputed.

\sphinxAtStartPar
Multipath TCP copes with these NATs by associating an identifier to each address that is used to create a subflow or advertise an address using the \sphinxcode{\sphinxupquote{ADD\_ADDR}} option. NAT are not aware of these identifiers and they do not modify them. The \sphinxcode{\sphinxupquote{REMOVE\_ADDR}} option only contains the identifier of the address that was removed. With this information, the receiver of the option can easily determine the affected subflows.

\sphinxAtStartPar
Most NAT deployments, in particular with IPv4, use a pool a public addresses that is much smaller than the set of private addresses that need to be mapped. These middleboxes also need to translate the source ports used by the internal hosts to map different private addresses to the same public addresses. These Network Address and Port Translators (NAPT) also modify the source or destination ports in the same way as they modify the addresses. Multipath TCP copes with simple NAPTs as with simple NATs. Unfortunately, most NATs and NAPTs also include Application\sphinxhyphen{}Level Gateways (ALG). ALGs were designed to enable applications such as the File Transfer Protocol (FTP) {[}\hyperlink{cite.biblio:id894}{31}{]} to be used through NATs and NAPTs. FTP and a few other protocols use IP addresses as parameters of the application\sphinxhyphen{}level messages that are exchanged within the bytestream. A simple FTP session is shown in \hyperref[\detokenize{mptcp:fig-mptcp-ftp}]{Listing \ref{\detokenize{mptcp:fig-mptcp-ftp}}}. In contrast with many application\sphinxhyphen{}level protocols, FTP uses several TCP connection. A FTP sessions starts with a TCP connection established by the client. This connection is called the control connection {[}\hyperlink{cite.biblio:id894}{31}{]}. This connection is used to exchange simple commands and the associated responses. The client issues commands such as \sphinxcode{\sphinxupquote{USER}} (to indicate the client username) or \sphinxcode{\sphinxupquote{PASS}} (to provide a password) as a single ASCII line sent over this connection. The server replies with one line that starts with a decimal number that indicates the success of the failure of the command and a textual explanation. However, this is not the only connection used between the client and the server. The client and the server also use data connections. If the client wants to retrieve a file or simply list the names of the files in a given directory, it needs to issue two successive commands. The first command (\sphinxcode{\sphinxupquote{PORT}}) indicates the data connection that will be used to exchange the result of the subsequent command. The client listens on a local port and provides its IP address and port number as parameters of the \sphinxcode{\sphinxupquote{PORT}} command. Upon reception of this command, the server establish a TCP connection towards the port specific by the client. If the client is behind a NAT, its private IP address and the local port must be translated by the NAT to support the establishment of a server\sphinxhyphen{}initiated connection.
\sphinxSetupCaptionForVerbatim{Simple ftp session}
\def\sphinxLiteralBlockLabel{\label{\detokenize{mptcp:fig-mptcp-ftp}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}ftp \PYGZhy{}4d ftp.belnet.be
\PYG{g+go}{Connected to ftp\PYGZhy{}brudie.belnet.be.}
\PYG{g+go}{220\PYGZhy{}Welcome to the Belnet public FTP server ftp.belnet.be !}

\PYG{g+go}{All access is logged.}

\PYG{g+go}{Currently used storage capacity : 38T / 100T on /ftp}
\PYG{g+go}{220 193.190.198.27 FTP server ready}
\PYG{g+go}{Name (ftp.belnet.be): anonymous}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} USER anonymous}
\PYG{g+go}{331 Anonymous login ok, send your complete email address as your password}
\PYG{g+go}{Password:}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} PASS XXXX}
\PYG{g+go}{230 Anonymous access granted, restrictions apply}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} SYST}
\PYG{g+go}{215 UNIX Type: L8}
\PYG{g+go}{Remote system type is UNIX.}
\PYG{g+go}{Using binary mode to transfer files.}
\PYG{g+go}{ftp\PYGZgt{} dir}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} PORT 192,168,0,37,133,67}
\PYG{g+go}{200 PORT command successful}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} LIST}
\PYG{g+go}{150 Opening ASCII mode data connection for file list}
\PYG{g+go}{lrw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 ftp      ftp            16 Feb 24  2021 arcolinux \PYGZhy{}\PYGZgt{} mirror/arcolinux}
\PYG{g+go}{drwxr\PYGZhy{}xr\PYGZhy{}x   3 ftp      ftp           101 Jan 12  2021 belnetstyle}
\PYG{g+go}{lrw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 ftp      ftp            13 Feb  1  2021 debian \PYGZhy{}\PYGZgt{} mirror/debian}
\PYG{g+go}{226 Transfer complete}
\PYG{g+go}{ftp\PYGZgt{} quit}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} QUIT}
\PYG{g+go}{221 Goodbye.}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is interesting to analyze how an ALG modifies a packet that carries such a \sphinxcode{\sphinxupquote{PORT}} command. Let us assume that the \sphinxcode{\sphinxupquote{PORT 192,168,0,37,133,67}} command is sent in a single TCP packet for simplicity. \hyperref[\detokenize{mptcp:fig-mptcp-ip4tcp-ftp-port}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-ip4tcp-ftp-port}}} shows the contents of the packet sent by the client. \hyperref[\detokenize{mptcp:fig-mptcp-ip4tcp-ftp-port2}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-ip4tcp-ftp-port2}}} shows the packet after its translation by the NAT, assuming that the NAT maps IP address \sphinxcode{\sphinxupquote{192.168.0.37}} onto address \sphinxcode{\sphinxupquote{5.6.7.8}}. The packet sent by client contains 26 bytes of payload. The IP packet is thus 66 bytes long.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\definecolor{lightcyan}{rgb}{0.84,1,1}
\definecolor{lightgray}{gray}{0.8}
\definecolor{lightred}{rgb}{1,0.7,0.71}
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{4}{Ver} &  \bitbox{4}{IHL} & \bitbox{6}{DSCP} & \bitbox{2}{\tiny ECN} & \bitbox{16}{len=66}  \\
\bitbox{16}{Identification} & \bitbox{3}{\tiny Flags} & \bitbox{13}{Offset} \\
\bitbox{8}{TTL} & \bitbox{8}{Protocol} & \bitbox{16}{IP Checksum} \\
\bitbox{32}[bgcolor=lightcyan]{192.168.0.37} \\
\bitbox{32}{193.190.198.27} \\
\bitbox{16}[bgcolor=lightcyan]{57258} &  \bitbox{16}{21} \\
\bitbox{32}[bgcolor=lightcyan]{seq=12300} \\
\bitbox{32}{ack=5678} \\
\bitbox{4}{Offset} & \bitbox{6}{Res} & \bitbox{1}{\tiny U\\R\\G} & \bitbox{1}{\tiny A\\C\\K} & \bitbox{1}{\tiny P\\S\\H} & \bitbox{1}{\tiny R\\S\\T} & \bitbox{1}{\tiny S\\Y\\N} & \bitbox{1}{\tiny F\\I\\N} & \bitbox{16}{16384} \\
\bitbox{16}{TCP Checksum} &  \bitbox{16}{Urgent Pointer} \\
\bitbox[lt]{8}[bgcolor=lightcyan]{P} & \bitbox[t]{8}[bgcolor=lightcyan]{O}&  \bitbox[t]{8}[bgcolor=lightcyan]{R} & \bitbox[tr]{8}[bgcolor=lightcyan]{T} \\
\bitbox[l]{8}[bgcolor=lightcyan]{} & \bitbox[]{8}[bgcolor=lightcyan]{1}&  \bitbox[]{8}[bgcolor=lightcyan]{9} & \bitbox[r]{8}[bgcolor=lightcyan]{2} \\
\bitbox[l]{8}[bgcolor=lightcyan]{,} & \bitbox[]{8}[bgcolor=lightcyan]{1}&  \bitbox[]{8}[bgcolor=lightcyan]{6} & \bitbox[r]{8}[bgcolor=lightcyan]{8} \\
\bitbox[l]{8}[bgcolor=lightcyan]{,} & \bitbox[]{8}[bgcolor=lightcyan]{0}&  \bitbox[]{8}[bgcolor=lightcyan]{,} & \bitbox[r]{8}[bgcolor=lightcyan]{3} \\
\bitbox[l]{8}[bgcolor=lightcyan]{7} & \bitbox[]{8}[bgcolor=lightcyan]{,}&  \bitbox[]{8}[bgcolor=lightcyan]{1} & \bitbox[r]{8}[bgcolor=lightcyan]{3} \\
\bitbox[l]{8}[bgcolor=lightcyan]{3} & \bitbox[]{8}[bgcolor=lightcyan]{,}&  \bitbox[b]{8}[bgcolor=lightcyan]{6} & \bitbox[br]{8}[bgcolor=lightcyan]{7} \\
\bitbox[bl]{8}[bgcolor=lightcyan]{CR} & \bitbox[br]{8}[bgcolor=lightcyan]{LF} \\
\end{bytefield}
};
\end{tikzpicture}\caption{Packet carrying a PORT command sent by a client}\label{\detokenize{mptcp:id80}}\label{\detokenize{mptcp:fig-mptcp-ip4tcp-ftp-port}}\end{figure}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{PORT 192,168,0,37,133,67}} indicates that the client listens on IP address \sphinxcode{\sphinxupquote{192.168.0.37}} and on port \(133*256+67=34115\). Let us assume that the NAT maps this IP address on address \sphinxcode{\sphinxupquote{5.6.7.8}} and port \sphinxcode{\sphinxupquote{34115}} on port \(31533=123*256+45\). In ASCII, the \sphinxcode{\sphinxupquote{PORT}} command becomes \sphinxcode{\sphinxupquote{PORT 5,6,7,8,123,45}} and the NAT sends the packet shown in \hyperref[\detokenize{mptcp:fig-mptcp-ip4tcp-ftp-port2}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-ip4tcp-ftp-port2}}}. The fields shown in red have been translated by the NAT. An important point to note contains 21 bytes of payload and not 66 as the packet sent by the client. This implies that the packet sent by the NAT contains the bytes having sequence numbers \sphinxcode{\sphinxupquote{12300}} to \sphinxcode{\sphinxupquote{12320}} while the original packet covered sequence numbers \sphinxcode{\sphinxupquote{12300}} to \sphinxcode{\sphinxupquote{12325}}. The NAT will thus need to adjust the sequence number of the subsequent packets sent by the client and also the acknowledgments returned by the server.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\definecolor{lightcyan}{rgb}{0.84,1,1}
\definecolor{lightgray}{gray}{0.8}
\definecolor{lightred}{rgb}{1,0.7,0.71}
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{4}{Ver} &  \bitbox{4}{IHL} & \bitbox{6}{DSCP} & \bitbox{2}{\tiny ECN} & \bitbox{16}[bgcolor=lightred]{len=61}  \\
\bitbox{16}{Identification} & \bitbox{3}{\tiny Flags} & \bitbox{13}{Offset} \\
\bitbox{8}[bgcolor=lightred]{TTL} & \bitbox{8}{Protocol} & \bitbox{16}[bgcolor=lightred]{IP Checksum} \\
\bitbox{32}[bgcolor=lightred]{5.6.7.8} \\
\bitbox{32}{193.190.198.27} \\
\bitbox{16}[bgcolor=lightred]{57258} &  \bitbox{16}{21} \\
\bitbox{32}[bgcolor=lightcyan]{seq=12300} \\
\bitbox{32}{ack=5678} \\
\bitbox{4}{Offset} & \bitbox{6}{Res} & \bitbox{1}{\tiny U\\R\\G} & \bitbox{1}{\tiny A\\C\\K} & \bitbox{1}{\tiny P\\S\\H} & \bitbox{1}{\tiny R\\S\\T} & \bitbox{1}{\tiny S\\Y\\N} & \bitbox{1}{\tiny F\\I\\N} & \bitbox{16}{16384} \\
\bitbox{16}[bgcolor=lightred]{TCP Checksum} &  \bitbox{16}{Urgent Pointer} \\
\bitbox[lt]{8}{P} & \bitbox[t]{8}{O}&  \bitbox[t]{8}{R} & \bitbox[tr]{8}{T} \\
\bitbox[l]{8}{} & \bitbox[]{8}[bgcolor=lightred]{5}&  \bitbox[]{8}[bgcolor=lightred]{,} & \bitbox[r]{8}[bgcolor=lightred]{6} \\
\bitbox[l]{8}[bgcolor=lightred]{,} & \bitbox[]{8}[bgcolor=lightred]{7}&  \bitbox[]{8}[bgcolor=lightred]{,} & \bitbox[r]{8}[bgcolor=lightred]{8} \\
\bitbox[l]{8}[bgcolor=lightred]{,} & \bitbox[]{8}[bgcolor=lightred]{1}&  \bitbox[]{8}[bgcolor=lightred]{2} & \bitbox[r]{8}[bgcolor=lightred]{3} \\
\bitbox[l]{8}[bgcolor=lightred]{,} & \bitbox[b]{8}[bgcolor=lightred]{4}&  \bitbox[b]{8}[bgcolor=lightred]{5} & \bitbox[br]{8}[bgcolor=lightred]{CR} \\
\bitbox[lbr]{8}[bgcolor=lightred]{LF} \\
\end{bytefield}
};
\end{tikzpicture}\caption{Packet carrying a PORT command modified by the FTP ALG used by a NAT}\label{\detokenize{mptcp:id81}}\label{\detokenize{mptcp:fig-mptcp-ip4tcp-ftp-port2}}\end{figure}
\sphinxAtStartPar
As shown by the example above, an ALG can change bytes in the bytestream. It can also remove bytes from the bytestream and also add bytes in the bytestream. This happens notably when the ASCII representation of the public IP address of the NAT is longer than the private IP address of the internal host. This modification of the bytestream had a major impact on the design of Multipath TCP. It mainly affects the Data Sequence Number option that carries the data sequence numbers and acknowledgments. To detect modifications from ALGs and other middleboxes, this option covers a range of sequence numbers in the bytestream and includes an optional checksum that is computed by the Multipath TCP sender and checked by the receiver. If there is a mismatch between the checksum of the option and the data, the receiver stops using Multipath TCP and falls back to regular TCP to preserve the established connection. We discuss this fallback in more details later.

\sphinxAtStartPar
Our third type of middlebox that splits or coalesces TCP packets. This is not a router that performs IPv4 fragmentation or a host that splits a large IPv6 packets in fragments. In\sphinxhyphen{}network fragmentation is mainly disabled in IPv4 network since modern TCP stacks set the \sphinxcode{\sphinxupquote{DF}} flag of the IP header. Those middleboxes do not reside in the middle of the network. They are typically included in the network adapter used by servers and even client hosts. Measurement studies have shown that hosts can reach a higher throughput when sending and receiving large packets. For example, a recent study {[}\hyperlink{cite.biblio:id8923}{32}{]} reveals that over a 100 Gbps interface, a server was able to reach 25 Gbps with a single TCP connection using 1500 bytes packets. The same connection reached 40 Gbps by using jumbo frames, i.e. 9000 bytes packets. The jumbo frames are supported on modern Gigabit Ethernet networks but they are rarely used outside datacenters because most Internet paths still only supports 1500 bytes packets.

\sphinxAtStartPar
Modern network adapters support TCP Segmentation Offload (TSO) to improve the throughput of TCP connection are reduce the CPU load. In a nutshell, when TSO is enabled, the network adapter exposes a large maximum packet size, e.g. 16 KBytes to more, to the network stack. When the host sends such a large packet, it is automatically segmented in a sequence of small IP packets. On the receiver side, the network adapter performs the reverse operation. It coalesces small received packets into a larger one. \hyperref[\detokenize{mptcp:fig-mptcp-tso}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-tso}}} shows a large (2 KBytes long) TCP packet. It is interesting to analyze how the key fields of this packet will be processed by TSO to segment it in the two smaller packets.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\definecolor{lightcyan}{rgb}{0.84,1,1}
\definecolor{lightgray}{gray}{0.8}
\definecolor{lightred}{rgb}{1,0.7,0.71}
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{4}{Ver} &  \bitbox{4}{IHL} & \bitbox{6}{DSCP} & \bitbox{2}{\tiny ECN} & \bitbox{16}[bgcolor=lightred]{Length=2040}  \\
\bitbox{16}[bgcolor=lightred]{Identification} & \bitbox{3}{\tiny Flags} & \bitbox{13}{Offset} \\
\bitbox{8}{TTL} & \bitbox{8}{Protocol} & \bitbox{16}[bgcolor=lightred]{IP Checksum} \\
\bitbox{32}{Source Address} \\
\bitbox{32}{Destination Address} \\
\bitbox{16}{Source Port} &  \bitbox{16}{Destination Port} \\
\bitbox{32}[bgcolor=lightred]{Sequence number} \\
\bitbox{32}{Acknowledgment number } \\
\bitbox{4}{Offset} & \bitbox{6}{Res} & \bitbox{1}{\tiny U\\R\\G} & \bitbox{1}{\tiny A\\C\\K} & \bitbox{1}{\tiny P\\S\\H} & \bitbox{1}{\tiny R\\S\\T} & \bitbox{1}{\tiny S\\Y\\N} & \bitbox{1}{\tiny F\\I\\N} & \bitbox{16}{Window} \\
\bitbox{16}[bgcolor=lightred]{Checksum} &  \bitbox{16}{Urgent Pointer} \\
\wordbox{3}[bgcolor=lightred]{TCP options}\\
\wordbox[ltr]{2}{Data}\\
\skippedwords \\
\wordbox[lrb]{2}{2000 bytes}\\
\end{bytefield}
};
\end{tikzpicture}\caption{A large IP packet containing TCP header and data}\label{\detokenize{mptcp:id82}}\label{\detokenize{mptcp:fig-mptcp-tso}}\end{figure}
\sphinxAtStartPar
To segment the packet shown in \hyperref[\detokenize{mptcp:fig-mptcp-tso}]{Fig.\@ \ref{\detokenize{mptcp:fig-mptcp-tso}}} in two smaller packets, TSO creates two \sphinxcode{\sphinxupquote{1040}} bytes long IPv4 packets. The two small packets have a different IP Identification than the large one. TSO computes an IP checksum for each small packet. It then copies the TCP header of the large packet in both small ones, but with a fed adjustments. The sequence number of the  first small packet is the same as the large one. The sequence number of the sequence small packet is the one of the first packet increased by 1000.
Concerning the TCP options, TSO could analyze the contents of the option and handle each option in a specific manner. For example, TSO could adjust the TCP timestamp option of successive packets. In practice, measurements indicate that TSO simply copies the TCP options field of the large packet in all small packets {[}\hyperlink{cite.biblio:id8938}{33}{]}. TSO places the first 1000 bytes of the payload of the large packet in the first small one and the last 1000 bytes in the second one. Finally, TSO needs to update the TCP checksum in all the small packets.

\sphinxAtStartPar
The receiver side of these network adapters implement Large Receive Offload (LRO). This basically coalesces the packets that were segmented by TSO. In this case, coalescing packets that carry different TCP options could be problematic since some of the TCP options would be lost in this process. Measurements with different TCP options show that LRO only coalesces packets that have exactly the same set of TCP implementations.
\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{16}{Source Port} &  \bitbox{16}{Destination Port} \\
\bitbox{32}{Sequence number} \\
\bitbox{32}{Acknowledgment number } \\
\bitbox{4}{Offset} & \bitbox{6}{Res} & \bitbox{1}{\tiny U\\R\\G} & \bitbox{1}{\tiny A\\C\\K} & \bitbox{1}{\tiny P\\S\\H} & \bitbox{1}{\tiny R\\S\\T} & \bitbox{1}{\tiny S\\Y\\N} & \bitbox{1}{\tiny F\\I\\N} & \bitbox{16}{Window} \\
\bitbox{16}{Checksum} &  \bitbox{16}{Urgent Pointer} \\
\bitbox[rlt]{32}{TCP options}\\
\bitbox[rlb]{24}{} & \bitbox{8}{Padding}\\
\end{bytefield}
};
\end{tikzpicture}\caption{The TCP header}\label{\detokenize{mptcp:id83}}\end{figure}

\section{The protocol details}
\label{\detokenize{mptcp:the-protocol-details}}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind} & \bitbox{8}{Length=12} & \bitbox{4}{0x1} & \bitbox{3}{rsv} & \bitbox{1}{B} & \bitbox{8}{Address ID} \\
\bitbox{32}{Receiver's token} \\
\bitbox{32}{Sender's random nonce} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The MP\_JOIN option in a SYN packet}\label{\detokenize{mptcp:id84}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind} & \bitbox{8}{Length=12} & \bitbox{4}{0x1} & \bitbox{3}{rsv} & \bitbox{1}{B} & \bitbox{8}{Address ID} \\
\wordbox{2}{Sender's truncated HMAC\\64 bits} \\
\bitbox{32}{Sender's random nonce} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The MP\_JOIN option in a SYN+ACK packet}\label{\detokenize{mptcp:id85}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind} & \bitbox{8}{Length=12} & \bitbox{4}{0x1} & \bitbox{3}{rsv} & \bitbox{1}{B} & \bitbox{8}{Address ID} \\
\wordbox{5}{Sender's truncated HMAC\\160 bits} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The MP\_JOIN option in the initiator’s first ACK}\label{\detokenize{mptcp:id86}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind} & \bitbox{8}{Length=12} & \bitbox{4}{0x2} & \bitbox{7}{reserved} & \bitbox{1}{\tiny{F}} & \bitbox{1}{\tiny{m}} & \bitbox{1}{\tiny{M}} & \bitbox{1}{\tiny{a}} & \bitbox{1}{\tiny{A}} \\
\bitbox{32}{Data ACK (4 or 8 bytes)}\\
\bitbox{32}{Data Sequence Number (4 or 8 bytes)}\\
\bitbox{32}{Subflow Sequence Number (4 or 8 bytes)}\\
\bitbox{16}{Data-Level Length} & \bitbox{16}{Checksum} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The Data Sequence Signal option}\label{\detokenize{mptcp:id87}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitbox{8}{Kind} & \bitbox{8}{Length} & \bitbox{4}{0x5} & \bitbox{3}{rsv} & \bitbox{1}{B} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The MP\_PRIO option}\label{\detokenize{mptcp:id88}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind} & \bitbox{8}{Length} & \bitbox{4}{0x3} & \bitbox{3}{rsv} & \bitbox{1}{E} & \bitbox{8}{Address ID} \\
\bitbox{32}{IP address (16 bytes for IPv6)}\\
\bitbox{16}{Port (2 bytes, opt.)} & \bitbox[lrt]{16}{} \\
\bitbox[lr]{32}{Truncated HMAC (64 bits if E=0)}\\
\bitbox[lbr]{16}{} && \bitbox[lt]{16}{}\\
\end{bytefield}
};
\end{tikzpicture}\caption{The ADD\_ADDR option}\label{\detokenize{mptcp:id89}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitbox{8}{Kind} & \bitbox{8}{Length=3+n} & \bitbox{4}{0x4} & \bitbox{4}{rsv} & \bitbox{8}{Address ID}\bitbox[]{2}{...} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The REMOVE\_ADDR option}\label{\detokenize{mptcp:id90}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind}
\bitbox{8}{Length} & \bitbox{4}{0x0} & \bitbox{4}{Ver} & \bitbox{1}{\tiny{A}} &  \bitbox{1}{\tiny{B}}  &  \bitbox{1}{\tiny{C}}  &  \bitbox{1}{\tiny{D}}  &  \bitbox{1}{\tiny{E}}  &  \bitbox{1}{\tiny{F}}  &  \bitbox{1}{\tiny{G}}  &  \bitbox{1}{H} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The MP\_CAPABLE option in a SYN packet}\label{\detokenize{mptcp:id91}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind}
\bitbox{8}{Length} & \bitbox{4}{0x0} & \bitbox{4}{Ver} & \bitbox{1}{\tiny{A}} &  \bitbox{1}{\tiny{B}}  &  \bitbox{1}{\tiny{C}}  &  \bitbox{1}{\tiny{D}}  &  \bitbox{1}{\tiny{E}}  &  \bitbox{1}{\tiny{F}}  &  \bitbox{1}{\tiny{G}}  &  \bitbox{1}{H} \\
\wordbox{2}{Sender's key (key) (64 bits)} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The MP\_CAPABLE option in SYN+ACK packet}\label{\detokenize{mptcp:id92}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind}
\bitbox{8}{Length} & \bitbox{4}{0x0} & \bitbox{4}{Ver} & \bitbox{1}{\tiny{A}} &  \bitbox{1}{\tiny{B}}  &  \bitbox{1}{\tiny{C}}  &  \bitbox{1}{\tiny{D}}  &  \bitbox{1}{\tiny{E}}  &  \bitbox{1}{\tiny{F}}  &  \bitbox{1}{\tiny{G}}  &  \bitbox{1}{H} \\
\wordbox{2}{Sender's key (key) (64 bits)} \\
\wordbox{2}{Receiver's key (key) (64 bits)} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The MP\_CAPABLE option in initiator’s first ACK (without data)}\label{\detokenize{mptcp:id93}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind}
\bitbox{8}{Length} & \bitbox{4}{0x0} & \bitbox{4}{Ver} & \bitbox{1}{\tiny{A}} &  \bitbox{1}{\tiny{B}}  &  \bitbox{1}{\tiny{C}}  &  \bitbox{1}{\tiny{D}}  &  \bitbox{1}{\tiny{E}}  &  \bitbox{1}{\tiny{F}}  &  \bitbox{1}{\tiny{G}}  &  \bitbox{1}{H} \\
\wordbox{2}{Sender's key (key) (64 bits)} \\
\wordbox{2}{Receiver's key (key) (64 bits)} \\
\bitbox{16}{Data-level length} & \bitbox{16}{Checksum (optional)}
\end{bytefield}
};
\end{tikzpicture}\caption{The MP\_CAPABLE option in initiator’s first ACK (with data)}\label{\detokenize{mptcp:id94}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind} & \bitbox{8}{Length} & \bitbox{4}{0x8} & \bitbox{1}{\tiny{U}} & \bitbox{1}{\tiny{V}} \bitbox{1}{\tiny{W}} \bitbox{1}{\tiny{T}} & \bitbox{8}{Reason} \\
\wordbox{2}{Receiver's key \\ 64 bits} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The MP\_TCPRST option}\label{\detokenize{mptcp:id95}}\end{figure}\begin{figure}[htbp]\centering\capstart\begin{tikzpicture}
\node (A) at (0,0)  {
\begin{bytefield}{32}
\bitheader{0-31}\\
\bitbox{8}{Kind} & \bitbox{8}{Length} & \bitbox{4}{0x7} & \bitbox{12}{reserved} \\
\wordbox{2}{Receiver's key \\ 64 bits} \\
\end{bytefield}
};
\end{tikzpicture}\caption{The FAST\_CLOSE option}\label{\detokenize{mptcp:id96}}\end{figure}

\chapter{Bibliography}
\label{\detokenize{biblio:bibliography}}\label{\detokenize{biblio::doc}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{10}
\bibitem[1]{biblio:id1948}
\sphinxAtStartPar
M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow. TCP Selective Acknowledgment Options. RFC 2018 (Proposed Standard), October 1996. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc2018.txt}, \sphinxhref{https://doi.org/10.17487/RFC2018}{doi:10.17487/RFC2018}.
\bibitem[2]{biblio:id729}
\sphinxAtStartPar
J. Postel. Transmission Control Protocol. RFC 793 (Internet Standard), September 1981. Updated by RFCs 1122, 3168, 6093, 6528. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc793.txt}, \sphinxhref{https://doi.org/10.17487/RFC0793}{doi:10.17487/RFC0793}.
\bibitem[3]{biblio:id831}
\sphinxAtStartPar
J. Nagle. Congestion Control in IP/TCP Internetworks. RFC 896 (Historic), January 1984. Obsoleted by RFC 7805. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc896.txt}, \sphinxhref{https://doi.org/10.17487/RFC0896}{doi:10.17487/RFC0896}.
\bibitem[4]{biblio:id6147}
\sphinxAtStartPar
V. Paxson, M. Allman, J. Chu, and M. Sargent. Computing TCP\textquotesingle{}s Retransmission Timer. RFC 6298 (Proposed Standard), June 2011. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc6298.txt}, \sphinxhref{https://doi.org/10.17487/RFC6298}{doi:10.17487/RFC6298}.
\bibitem[5]{biblio:id8500}
\sphinxAtStartPar
A. Ford, C. Raiciu, M. Handley, O. Bonaventure, and C. Paasch. TCP Extensions for Multipath Operation with Multiple Addresses. RFC 8684 (Proposed Standard), March 2020. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc8684.txt}, \sphinxhref{https://doi.org/10.17487/RFC8684}{doi:10.17487/RFC8684}.
\bibitem[6]{biblio:id6658}
\sphinxAtStartPar
A. Ford, C. Raiciu, M. Handley, and O. Bonaventure. TCP Extensions for Multipath Operation with Multiple Addresses. RFC 6824 (Experimental), January 2013. Obsoleted by RFC 8684. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc6824.txt}, \sphinxhref{https://doi.org/10.17487/RFC6824}{doi:10.17487/RFC6824}.
\bibitem[7]{biblio:id2922}
\sphinxAtStartPar
C. Hopps. Analysis of an Equal\sphinxhyphen{}Cost Multi\sphinxhyphen{}Path Algorithm. RFC 2992 (Informational), November 2000. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc2992.txt}, \sphinxhref{https://doi.org/10.17487/RFC2992}{doi:10.17487/RFC2992}.
\bibitem[8]{biblio:id6033}
\sphinxAtStartPar
A. Ford, C. Raiciu, M. Handley, S. Barre, and J. Iyengar. Architectural Guidelines for Multipath TCP Development. RFC 6182 (Informational), March 2011. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc6182.txt}, \sphinxhref{https://doi.org/10.17487/RFC6182}{doi:10.17487/RFC6182}.
\bibitem[9]{biblio:id8227}
\sphinxAtStartPar
C. Filsfils (Ed.), S. Previdi (Ed.), L. Ginsberg, B. Decraene, S. Litkowski, and R. Shakir. Segment Routing Architecture. RFC 8402 (Proposed Standard), July 2018. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc8402.txt}, \sphinxhref{https://doi.org/10.17487/RFC8402}{doi:10.17487/RFC8402}.
\bibitem[10]{biblio:id8570}
\sphinxAtStartPar
C. Filsfils (Ed.), D. Dukes (Ed.), S. Previdi, J. Leddy, S. Matsushima, and D. Voyer. IPv6 Segment Routing Header (SRH). RFC 8754 (Proposed Standard), March 2020. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc8754.txt}, \sphinxhref{https://doi.org/10.17487/RFC8754}{doi:10.17487/RFC8754}.
\bibitem[11]{biblio:id8933}
\sphinxAtStartPar
C. Raiciu, S. Barre, C. Pluntke, A. Greenhalgh, D. Wischik, and M. Handley. Improving Datacenter Performance and Robustness with Multipath TCP. In \sphinxstyleemphasis{ACM SIGCOMM 2011}. 2011. URL: \sphinxurl{http://doi.acm.org/10.1145/2018436.2018467}, \sphinxhref{https://doi.org/10.1145/2018436.2018467}{doi:10.1145/2018436.2018467}.
\bibitem[12]{biblio:id2034}
\sphinxAtStartPar
H. Krawczyk, M. Bellare, and R. Canetti. HMAC: Keyed\sphinxhyphen{}Hashing for Message Authentication. RFC 2104 (Informational), February 1997. Updated by RFC 6151. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc2104.txt}, \sphinxhref{https://doi.org/10.17487/RFC2104}{doi:10.17487/RFC2104}.
\bibitem[13]{biblio:id6032}
\sphinxAtStartPar
M. Bagnulo. Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses. RFC 6181 (Informational), March 2011. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc6181.txt}, \sphinxhref{https://doi.org/10.17487/RFC6181}{doi:10.17487/RFC6181}.
\bibitem[14]{biblio:id8271}
\sphinxAtStartPar
E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.3. RFC 8446 (Proposed Standard), August 2018. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc8446.txt}, \sphinxhref{https://doi.org/10.17487/RFC8446}{doi:10.17487/RFC8446}.
\bibitem[15]{biblio:id1255}
\sphinxAtStartPar
V. Jacobson, R. Braden, and D. Borman. TCP Extensions for High Performance. RFC 1323 (Proposed Standard), May 1992. Obsoleted by RFC 7323. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc1323.txt}, \sphinxhref{https://doi.org/10.17487/RFC1323}{doi:10.17487/RFC1323}.
\bibitem[16]{biblio:id6083}
\sphinxAtStartPar
D. Eastlake 3rd and T. Hansen. US Secure Hash Algorithms (SHA and SHA\sphinxhyphen{}based HMAC and HKDF). RFC 6234 (Informational), May 2011. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc6234.txt}, \sphinxhref{https://doi.org/10.17487/RFC6234}{doi:10.17487/RFC6234}.
\bibitem[17]{biblio:id8941}
\sphinxAtStartPar
Costin Raiciu, Christoph Paasch, Sebastien Barre, Alan Ford, Michio Honda, Fabien Duchene, Olivier Bonaventure, and Mark Handley. How hard can it be? Designing and implementing a deployable Multipath TCP. In \sphinxstyleemphasis{Proceedings of the 9th USENIX Conference on Networked Systems Design and Implementation}, NSDI\textquotesingle{}12, 29\textendash{}29. Berkeley, CA, USA, 2012. USENIX Association. URL: \sphinxurl{http://inl.info.ucl.ac.be/publications/how-hard-can-it-be-designing-and-implementing-deployable-multipath-tcp}.
\bibitem[18]{biblio:id9001}
\sphinxAtStartPar
Nicolas Keukeleire, Benjamin Hesmans, and Olivier Bonaventure. Increasing broadband reach with hybrid access networks. \sphinxstyleemphasis{IEEE Communications Standards Magazine}, 4(1):43\textendash{}49, 2020.
\bibitem[19]{biblio:id8932}
\sphinxAtStartPar
Damon Wischik, Costin Raiciu, Adam Greenhalgh, and Mark Handley. Design, implementation and evaluation of congestion control for Multipath TCP. In \sphinxstyleemphasis{Proceedings of the 8th USENIX Conference on Networked Systems Design and Implementation}, NSDI\textquotesingle{}11, 99\textendash{}112. Berkeley, CA, USA, 2011. USENIX Association. URL: \sphinxurl{http://dl.acm.org/citation.cfm?id=1972457.1972468}.
\bibitem[20]{biblio:id6203}
\sphinxAtStartPar
C. Raiciu, M. Handley, and D. Wischik. Coupled Congestion Control for Multipath Transport Protocols. RFC 6356 (Experimental), October 2011. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc6356.txt}, \sphinxhref{https://doi.org/10.17487/RFC6356}{doi:10.17487/RFC6356}.
\bibitem[21]{biblio:id8951}
\sphinxAtStartPar
R. Khalili, N. Gast, M. Popovic, and J.\sphinxhyphen{}Y. Le Boudec. MPTCP is not pareto\sphinxhyphen{}optimal: performance issues and a possible solution. \sphinxstyleemphasis{Networking, IEEE/ACM Transactions on}, 21(5):1651\textendash{}1665, Oct 2013. \sphinxhref{https://doi.org/10.1109/TNET.2013.2274462}{doi:10.1109/TNET.2013.2274462}.
\bibitem[22]{biblio:id8993}
\sphinxAtStartPar
Qiuyu Peng, Anwar Walid, Jaehyun Hwang, and Steven H Low. Multipath tcp: analysis, design, and implementation. \sphinxstyleemphasis{IEEE/ACM Transactions on networking}, 24(1):596\textendash{}609, 2014.
\bibitem[23]{biblio:id9002}
\sphinxAtStartPar
Tomer Gilad, Neta Rozen\sphinxhyphen{}Schiff, P Brighten Godfrey, Costin Raiciu, and Michael Schapira. Mpcc: online learning multipath transport. In \sphinxstyleemphasis{Proceedings of the 16th International Conference on emerging Networking EXperiments and Technologies}, 121\textendash{}135. 2020.
\bibitem[24]{biblio:id5818}
\sphinxAtStartPar
A. Ramaiah, R. Stewart, and M. Dalal. Improving TCP\textquotesingle{}s Robustness to Blind In\sphinxhyphen{}Window Attacks. RFC 5961 (Proposed Standard), August 2010. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc5961.txt}, \sphinxhref{https://doi.org/10.17487/RFC5961}{doi:10.17487/RFC5961}.
\bibitem[25]{biblio:id5558}
\sphinxAtStartPar
F. de Bont, S. Doehla, M. Schmidt, and R. Sperschneider. RTP Payload Format for Elementary Streams with MPEG Surround Multi\sphinxhyphen{}Channel Audio. RFC 5691 (Proposed Standard), October 2009. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc5691.txt}, \sphinxhref{https://doi.org/10.17487/RFC5691}{doi:10.17487/RFC5691}.
\bibitem[26]{biblio:id8916}
\sphinxAtStartPar
Justine Sherry, Shaddi Hasan, Colin Scott, Arvind Krishnamurthy, Sylvia Ratnasamy, and Vyas Sekar. Making middleboxes someone else\textquotesingle{}s problem: network processing as a cloud service. \sphinxstyleemphasis{ACM SIGCOMM Computer Communication Review}, 42(4):13\textendash{}24, 2012.
\bibitem[27]{biblio:id7140}
\sphinxAtStartPar
K. Patel, E. Chen, and B. Venkatachalapathy. Enhanced Route Refresh Capability for BGP\sphinxhyphen{}4. RFC 7313 (Proposed Standard), July 2014. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc7313.txt}, \sphinxhref{https://doi.org/10.17487/RFC7313}{doi:10.17487/RFC7313}.
\bibitem[28]{biblio:id1245}
\sphinxAtStartPar
C. Partridge. Today\textquotesingle{}s Programming for KRFC AM 1313 Internet Talk Radio. RFC 1313 (Informational), April 1992. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc1313.txt}, \sphinxhref{https://doi.org/10.17487/RFC1313}{doi:10.17487/RFC1313}.
\bibitem[29]{biblio:id2952}
\sphinxAtStartPar
P. Srisuresh and K. Egevang. Traditional IP Network Address Translator (Traditional NAT). RFC 3022 (Informational), January 2001. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc3022.txt}, \sphinxhref{https://doi.org/10.17487/RFC3022}{doi:10.17487/RFC3022}.
\bibitem[30]{biblio:id1848}
\sphinxAtStartPar
Y. Rekhter, B. Moskowitz, D. Karrenberg, G. J. de Groot, and E. Lear. Address Allocation for Private Internets. RFC 1918 (Best Current Practice), February 1996. Updated by RFC 6761. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc1918.txt}, \sphinxhref{https://doi.org/10.17487/RFC1918}{doi:10.17487/RFC1918}.
\bibitem[31]{biblio:id894}
\sphinxAtStartPar
J. Postel and J. Reynolds. File Transfer Protocol. RFC 959 (Internet Standard), October 1985. Updated by RFCs 2228, 2640, 2773, 3659, 5797, 7151. URL: \sphinxurl{https://www.rfc-editor.org/rfc/rfc959.txt}, \sphinxhref{https://doi.org/10.17487/RFC0959}{doi:10.17487/RFC0959}.
\bibitem[32]{biblio:id8923}
\sphinxAtStartPar
Mario Hock, Maxime Veit, Felix Neumeister, Roland Bless, and Martina Zitterbart. TCP at 100 Gbit/s\textendash{}tuning, limitations, congestion control. In \sphinxstyleemphasis{2019 IEEE 44th Conference on Local Computer Networks (LCN)}, 1\textendash{}9. IEEE, 2019.
\bibitem[33]{biblio:id8938}
\sphinxAtStartPar
Michio Honda, Yoshifumi Nishida, Costin Raiciu, Adam Greenhalgh, Mark Handley, and Hideyuki Tokuda. Is it still possible to extend TCP? In \sphinxstyleemphasis{Proceedings of the 2011 ACM SIGCOMM Conference on Internet Measurement Conference}, IMC \textquotesingle{}11, 181\textendash{}194. New York, NY, USA, 2011. ACM. URL: \sphinxurl{http://doi.acm.org/10.1145/2068816.2068834}, \sphinxhref{https://doi.org/10.1145/2068816.2068834}{doi:10.1145/2068816.2068834}.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}